/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * TYPED REDUX HOOKS
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * Pre-typed useDispatch and useSelector hooks for consistency across the app.
 * Use these instead of importing from 'react-redux' directly.
 */

import { useDispatch, useSelector } from 'react-redux';
import type { RootState, AppDispatch } from './store';

/**
 * Use this hook instead of plain useDispatch.
 * It provides type-safe dispatch with all actions available.
 * 
 * @example
 * const dispatch = useAppDispatch();
 * dispatch(simulationActions.updatePlayerCash(1000));
 */
export const useAppDispatch = () => useDispatch<AppDispatch>();

/**
 * Use this hook instead of plain useSelector.
 * It provides type-safe state selection with full RootState typing.
 * 
 * @example
 * const cash = useAppSelector((state) => state.simulation.cash);
 * const items = useAppSelector((state) => state.compendium.items);
 */
export const useAppSelector = useSelector.withTypes<RootState>();

/**
 * Convenience hook for getting the full simulation state
 * 
 * @example
 * const sim = useSimulationState();
 * console.log(sim.cash, sim.gold_bars, sim.rank);
 */
export const useSimulationState = () =>
  useAppSelector((state) => state.simulation);

/**
 * Convenience hook for getting the full compendium state
 * 
 * @example
 * const compendium = useCompendiumState();
 * console.log(compendium.items['w_mauser']);
 */
export const useCompendiumState = () =>
  useAppSelector((state) => state.compendium);

/**
 * Convenience hook for getting environment state (time, weather, bonuses)
 * 
 * @example
 * const env = useEnvironmentState();
 * console.log(env.time_of_day, env.active_bonuses);
 */
export const useEnvironmentState = () =>
  useAppSelector((state) => state.environment);

/**
 * Convenience hook for getting economics cache state
 * 
 * @example
 * const econ = useEconomicsState();
 * console.log(econ.calculated_profits);
 */
export const useEconomicsState = () =>
  useAppSelector((state) => state.economics);

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * COMPENDIUM SELECTORS - Derived State
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * These selectors extract and derive state from the compendium reducer.
 * Use these in components instead of directly accessing state.
 */

import { RootState } from '../app/store';

/**
 * Get the loading status of the compendium
 * @example
 * const status = useAppSelector(selectCompendiumStatus);
 * if (status === 'loading') return <LoadingScreen />;
 */
export const selectCompendiumStatus = (state: RootState) => {
  if (!state.compendium.data) {
    if (state.compendium.error) return 'error';
    if (state.compendium.loading) return 'loading';
    return 'idle';
  }
  return 'ready';
};

/**
 * Get the error message if compendium failed to load
 */
export const selectCompendiumError = (state: RootState) => state.compendium.error;

/**
 * Check if compendium is currently loading
 */
export const selectCompendiumIsLoading = (state: RootState) => state.compendium.loading;

/**
 * Get all catalog items
 */
export const selectAllItems = (state: RootState) => state.compendium.data?.items || [];

/**
 * Get all animals
 */
export const selectAllAnimals = (state: RootState) => state.compendium.data?.animals || [];

/**
 * Get a specific item by ID
 */
export const selectItemById = (id: string) => (state: RootState) =>
  state.compendium.data?.items.find((item) => item.id === id);

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * REDUX STORE CONFIGURATION - THE SWITCHBOARD
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * This file merges all slices (simulation, compendium, environment) into one
 * centralized state tree. It acts as the "switchboard" for the entire app.
 */

import { configureStore, combineReducers } from '@reduxjs/toolkit';

// Import slices (we'll create these next)
import simulationReducer from '../features/simulationSlice.ts';
import compendiumReducer from '../features/compendiumSlice.ts';
import environmentReducer from '../features/environmentSlice.ts';
import economicsReducer from '../features/economicsSlice.ts';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ROOT REDUCER - Combines all system reducers
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const rootReducer = combineReducers({
  // Player Simulation State (Cash, Gold, Rank, etc.)
  simulation: simulationReducer,
  
  // The Compendium (Static Data - Items, Animals, Formulas)
  compendium: compendiumReducer,
  
  // Environment State (Time of Day, Weather, Active Bonuses)
  environment: environmentReducer,
  
  // Economics Calculators (Cached Economic Data)
  economics: economicsReducer,
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STORE CONFIGURATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: false, // Optimize for large JSON data from compendium
    }),
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TYPE EXPORTS (For use throughout the app)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STORE PERSISTENCE (LocalStorage)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Save a portion of state to localStorage
 * Usage: saveStateToStorage('simulation', store.getState().simulation)
 */
export const saveStateToStorage = (key: string, state: any) => {
  try {
    const serialized = JSON.stringify(state);
    localStorage.setItem(`rdo_sim_${key}`, serialized);
  } catch (error) {
    console.error(`Failed to save ${key} to localStorage:`, error);
  }
};

/**
 * Load state from localStorage
 * Usage: const saved = loadStateFromStorage('simulation')
 */
export const loadStateFromStorage = (key: string) => {
  try {
    const serialized = localStorage.getItem(`rdo_sim_${key}`);
    return serialized ? JSON.parse(serialized) : null;
  } catch (error) {
    console.error(`Failed to load ${key} from localStorage:`, error);
    return null;
  }
};

/**
 * Clear all stored state
 */
export const clearAllStorage = () => {
  ['simulation', 'environment', 'economics'].forEach((key) => {
    try {
      localStorage.removeItem(`rdo_sim_${key}`);
    } catch (error) {
      console.error(`Failed to clear ${key}:`, error);
    }
  });
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXPORT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export default store;

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * RDO UNIFIED SCHEMA - THE CONTRACT
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * This file defines all TypeScript interfaces for the RDO Simulator.
 * It acts as "The Contract" - all data must conform to these shapes.
 * When adding new systems (Naturalist, Poker, etc.), add new interfaces here first.
 */

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DATA QUALITY & SOURCE TRACKING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export type ConfidenceLevel = 'HIGH' | 'MEDIUM' | 'LOW';
export type DataSource = 'GAME_TEST' | 'REDDIT' | 'WIKI' | 'YOUTUBE' | 'COMMUNITY_TESTED' | 'CALCULATED';

export interface DataQuality {
  confidence: ConfidenceLevel;
  sources: Array<{
    type: DataSource;
    date: string;
    verified_by?: string;
    url?: string;
    notes?: string;
  }>;
  last_verified: string;
  patch_version?: string;
  deprecation_warning?: string;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PLAYER CHARACTER STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export interface PlayerCharacter {
  character_id: string;
  rank: number;                          // 1-500
  cash: number;
  gold_bars: number;
  honor_level: number;                   // -8 to +8
  health_level: number;                  // 1-5
  stamina_level: number;                 // 1-5
  dead_eye_level: number;                // 1-5
  
  // Role Ranks (0-20 each)
  trader_rank: number;
  moonshiner_rank: number;
  bounty_hunter_rank: number;
  collector_rank: number;
  naturalist_rank: number;
  
  // Role States
  trader_goods: number;                  // 0-100
  trader_wagon_size: 'small' | 'medium' | 'large';
  moonshiner_shack_level: number;        // 1-3
  moonshiner_current_batch: 'weak' | 'average' | 'strong' | null;
  moonshiner_batch_progress: number;     // 0-100
  
  // Session State
  in_posse: boolean;
  roles_owned: string[];
  current_location: string;
  camp_location: string;
  last_update: number;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CATALOG ITEMS (The Master Truth)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export type ItemCategory = 'weapon' | 'horse' | 'clothing' | 'consumable' | 'tool' | 'upgrade' | 'vehicle';
export type ItemShop = 'gunsmith' | 'stable' | 'tailor' | 'fence' | 'general' | 'nazar' | 'role_vendor' | 'harriet';

export interface CatalogItem {
  id: string;
  name: string;
  category: ItemCategory;
  shop: ItemShop;
  
  // Pricing (multi-currency)
  price: number;                         // Cash
  gold_cost?: number;                    // Gold bars (optional)
  tokens?: number;                       // Role tokens (optional)
  
  // Unlock Requirements
  rank_required: number;
  role?: string;                         // If role-specific
  role_rank_required?: number;
  
  // Item Details
  description: string;
  type?: string;                         // e.g., "Sidearm", "Horse Breed"
  rarity?: string;                       // Common, Uncommon, Rare, Legendary
  stats?: Record<string, number>;        // e.g., { accuracy: 8, damage: 9 }
  
  // Data Quality
  data_quality: DataQuality;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ANIMALS & HUNTING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export interface AnimalSpawn {
  region: string;
  latitude: number;
  longitude: number;
  time_of_day: 'dawn' | 'day' | 'dusk' | 'night' | 'all';
  weather: string[];                     // Clear, rainy, snowy, etc.
  frequency: 'common' | 'uncommon' | 'rare';
}

export interface AnimalMaterial {
  name: string;
  value: number;                         // Cash value
  yield_probability: number;             // 0-1
  hunting_method: 'rifle' | 'sniper' | 'shotgun' | 'pistol' | 'knife' | 'melee' | 'poison' | 'trap';
  quality_tiers: {
    poor: number;
    good: number;
    perfect: number;
  };
}

export interface Animal {
  id: string;
  name: string;
  species: string;
  size: 'tiny' | 'small' | 'medium' | 'large' | 'massive';
  ai_rating: number;                     // 1-10 difficulty
  health: number;
  stamina: number;
  
  // Hunting Economics
  materials: AnimalMaterial[];
  average_hunt_time: number;             // Seconds
  average_profit: number;                // Cash per hunt
  
  // Spawning
  spawns: AnimalSpawn[];
  
  // Naturalist Integration
  can_study: boolean;
  sample_value: number;                  // Gold bars from Harriet
  sedative_ammo_type: 'rifle' | 'pistol';
  
  // Data Quality
  data_quality: DataQuality;
}

export interface LegendaryAnimal extends Animal {
  is_legendary: true;
  location_fixed: { latitude: number; longitude: number };
  spawn_condition?: string;              // e.g., "After killing 3 regular Cougars"
  challenge_reward: number;              // Cash reward for killing
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ECONOMIC FORMULAS (The Rules)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export interface EconomicFormula {
  id: string;
  name: string;
  description: string;
  formula_text: string;                  // Human-readable formula
  implementation: string;                // JavaScript function as string (or use function reference)
  variables: Record<string, string>;     // Variable descriptions
  examples: Array<{
    inputs: Record<string, number>;
    output: number;
    description: string;
  }>;
  data_quality: DataQuality;
}

// Specific Formula Interfaces (extend as needed)

export interface BountyPayoutFormula extends EconomicFormula {
  base_amount: number;
  multipliers: {
    tier: number;                        // 1.0, 1.25, 1.5 based on bounty tier
    status: number;                      // 1.0 (alive) or 0.5 (dead)
    time: number;                        // Dynamic, based on time held
    count: number;                       // 1.0, 1.67, 2.0 for multiple targets
  };
}

export interface TraderPayoutFormula extends EconomicFormula {
  materials_required: number;
  supplies_required: number;
  production_time: number;               // Seconds
  cash_per_good: number;
  supplies_bonus: number;                // Added cash from supplies
}

export interface MoonshinerPayoutFormula extends EconomicFormula {
  batch_cost: number;                    // Cash cost of mash
  production_time: number;               // Seconds
  quality_multipliers: {
    weak: number;
    average: number;
    strong: number;
  };
  batch_size: number;                    // Bottles per batch
}

export interface CollectorPayoutFormula extends EconomicFormula {
  set_completion_bonus: number;
  item_value: number;
  cycle_length: number;                  // Days before items respawn
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GEOGRAPHIC SYSTEMS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export interface FastTravelNode {
  id: string;
  name: string;
  latitude: number;
  longitude: number;
  location_type: 'camp' | 'town' | 'station' | 'hideout';
  region: string;
}

export interface FastTravelRoute {
  from_node: string;
  to_node: string;
  distance_miles: number;
  cost_cash: number;
  cost_gold?: number;
  travel_time: number;                   // Seconds
  is_exploit?: boolean;                  // True if (e.g., Wilderness Camp $1 exploit)
}

export interface Region {
  id: string;
  name: string;
  center_lat: number;
  center_lon: number;
  boundaries: {
    north: number;
    south: number;
    east: number;
    west: number;
  };
  dominant_animals: string[];            // Animal IDs
  fast_travel_nodes: string[];           // Node IDs
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ROLES & PROGRESSION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export interface RoleUnlock {
  gold_cost: number;
  player_rank_required: number;
  description: string;
}

export interface RoleRankBenefit {
  rank: number;
  name: string;
  description: string;
  unlocks?: string[];                    // Item IDs or feature names
}

export interface Role {
  id: string;
  name: string;
  npc_mentor: string;
  unlock_cost: RoleUnlock;
  rank_benefits: RoleRankBenefit[];
  max_rank: number;
  description: string;
  icon?: string;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SIMULATION & AFFORDABILITY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export interface SimulationAdjustments {
  cash_bonus: number;
  gold_bonus: number;
  rank_boost: number;
  time_multiplier: number;               // 1.0 = normal, 0.5 = double speed, 2.0 = half speed
}

export interface SimulationState extends PlayerCharacter {
  adjustments: SimulationAdjustments;
  projected_purchases: string[];         // Item IDs
  is_simulation_mode: boolean;
}

export interface AffordabilityResult {
  can_afford: boolean;
  reasons?: string[];
  deficit?: {
    cash?: number;
    gold?: number;
    tokens?: number;
  };
}

export interface RoleGatingResult {
  unlocked: boolean;
  missing_requirements?: string[];
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COLLECTION & COLLECTORS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export interface CollectorSet {
  id: string;
  name: string;
  category: string;
  items: string[];                       // Item IDs
  completion_bonus: number;
  cycle: number;                         // Which 7-day cycle (1-6)
  set_number: number;                    // For sequential displays
}

export interface CollectorCompletionStatus {
  set_id: string;
  found_items: string[];
  completion_percentage: number;
  total_earned: number;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ECONOMIC BONUS SYSTEMS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export interface EconomicBonus {
  id: string;
  name: string;
  description: string;
  bonus_type: 'cash_multiplier' | 'gold_multiplier' | 'role_xp' | 'activity_bonus';
  multiplier: number;
  start_date: string;
  end_date: string;
  affected_activities: string[];
  data_quality: DataQuality;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COMPENDIUM (The Master Collection)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export interface RDOCompendium {
  version: string;
  last_updated: string;
  game_version: string;                  // RDO patch version
  
  // Core Systems
  items: Record<string, CatalogItem>;    // Indexed by ID
  animals: Record<string, Animal | LegendaryAnimal>;
  
  // Economics
  formulas: Record<string, EconomicFormula>;
  bonuses: EconomicBonus[];
  
  // Geography
  regions: Record<string, Region>;
  fast_travel_nodes: Record<string, FastTravelNode>;
  fast_travel_routes: FastTravelRoute[];
  
  // Roles & Progression
  roles: Record<string, Role>;
  
  // Collectors
  collector_sets: CollectorSet[];
  
  // Metadata
  data_quality_summary: {
    high_confidence_items: number;
    medium_confidence_items: number;
    low_confidence_items: number;
    last_verification_date: string;
  };
}

// RDO Master Catalogue Data
// Each item: id, shop, name, price, gold, rank, type, desc, [tokens], [role]

const MASTER_CATALOG = [
  // --- GUNSMITH ---
  { id: 'w_navy', shop: 'gunsmith', name: 'Navy Revolver', price: 275.00, gold: 0, rank: 1, type: 'Sidearm', desc: 'High damage, slow reload' },
  { id: 'w_lemat', shop: 'gunsmith', name: 'LeMat Revolver', price: 317.00, gold: 0, rank: 1, type: 'Sidearm', desc: '9 rounds + shotgun shell' },
  { id: 'w_schofield', shop: 'gunsmith', name: 'Schofield Revolver', price: 192.00, gold: 0, rank: 9, type: 'Sidearm', desc: 'High accuracy' },
  { id: 'w_volcanic', shop: 'gunsmith', name: 'Volcanic Pistol', price: 270.00, gold: 0, rank: 21, type: 'Sidearm', desc: 'Lever-action pistol' },
  { id: 'w_lancaster', shop: 'gunsmith', name: 'Lancaster Repeater', price: 243.00, gold: 0, rank: 12, type: 'Longarm', desc: 'Best all-around repeater' },
  { id: 'w_bolt', shop: 'gunsmith', name: 'Bolt Action Rifle', price: 216.00, gold: 0, rank: 7, type: 'Longarm', desc: 'Essential for hunting' },
  { id: 'w_carcano', shop: 'gunsmith', name: 'Carcano Rifle', price: 456.00, gold: 0, rank: 50, type: 'Longarm', desc: 'Meta sniper rifle' },
  { id: 'w_rolling', shop: 'gunsmith', name: 'Rolling Block Rifle', price: 411.00, gold: 0, rank: 13, type: 'Longarm', desc: 'High damage sniper' },
  { id: 'w_pump', shop: 'gunsmith', name: 'Pump Action Shotgun', price: 266.00, gold: 0, rank: 5, type: 'Longarm', desc: 'Reliable close quarters' },
  { id: 'w_bow_imp', shop: 'gunsmith', name: 'Improved Bow', price: 275.00, gold: 0, rank: 10, type: 'Longarm', desc: 'Silent kills, massive range' },
  { id: 'a_express_rifle', shop: 'gunsmith', name: 'Express Rifle Ammo', price: 0.80, gold: 0, rank: 31, type: 'Ammo', desc: 'Box of 60' },
  { id: 'a_express_rev', shop: 'gunsmith', name: 'Express Revolver Ammo', price: 0.80, gold: 0, rank: 31, type: 'Ammo', desc: 'Box of 60' },

  // --- STABLES ---
  { id: 'h_arabian_black', shop: 'stable', name: 'Black Arabian', price: 0, gold: 42, rank: 70, type: 'Superior', desc: 'Elite handling' },
  { id: 'h_mft_amber', shop: 'stable', name: 'Missouri Fox Trotter', price: 950.00, gold: 0, rank: 58, type: 'Multi', desc: 'Top tier speed/stamina' },
  { id: 'h_turk_gold', shop: 'stable', name: 'Turkoman (Gold)', price: 950.00, gold: 0, rank: 56, type: 'Multi', desc: 'High health war/race hybrid' },
  { id: 'h_mustang_buck', shop: 'stable', name: 'Mustang (Buckskin)', price: 500.00, gold: 0, rank: 1, type: 'Multi', desc: 'The budget king. Brave & healthy.' },
  { id: 'h_nacho', shop: 'stable', name: 'Nacogdoches Saddle', price: 512.00, gold: 0, rank: 35, type: 'Tack', desc: 'The meta saddle' },
  { id: 'h_hooded', shop: 'stable', name: 'Hooded Stirrups', price: 144.00, gold: 0, rank: 54, type: 'Tack', desc: '+50% Drain Reduction' },

  // --- FENCE ---
  { id: 'f_dynamite', shop: 'fence', name: 'Dynamite Arrow Pamphlet', price: 895.00, gold: 0, rank: 93, type: 'Recipe', desc: 'Craft explosive arrows' },
  { id: 'f_incendiary', shop: 'fence', name: 'Incendiary Buckshot Pamphlet', price: 950.00, gold: 0, rank: 80, type: 'Recipe', desc: 'Craft fire shells' },
  { id: 'f_explosive', shop: 'fence', name: 'Explosive Slug Pamphlet', price: 950.00, gold: 0, rank: 84, type: 'Recipe', desc: 'Craft explosive slugs' },
  { id: 'f_machete', shop: 'fence', name: 'Machete', price: 40.00, gold: 0, rank: 32, type: 'Melee', desc: 'Sharp blade' },
  { id: 'f_hatchet', shop: 'fence', name: 'Cleaver', price: 40.00, gold: 0, rank: 5, type: 'Melee', desc: 'Thrown weapon' },

  // --- TAILOR ---
  { id: 'c_morning', shop: 'tailor', name: 'Morning Tail Coat', price: 125.00, gold: 0, rank: 1, type: 'Coat', desc: 'Formal attire' },
  { id: 'c_bandolier', shop: 'tailor', name: 'Double Bandolier', price: 325.00, gold: 0, rank: 20, type: 'Accessory', desc: 'Increased ammo capacity' },
  { id: 'c_grizzlies', shop: 'tailor', name: 'The Grizzlies Outlaw', price: 0, gold: 52, rank: 1, type: 'Outfit', desc: 'Warm weather gear' },

  // --- GENERAL STORE ---
  { id: 'g_beans', shop: 'general', name: 'Canned Beans', price: 0.60, gold: 0, rank: 1, type: 'Provisions', desc: 'Staple food' },
  { id: 'g_miracle', shop: 'general', name: 'Potent Miracle Tonic', price: 4.50, gold: 0, rank: 1, type: 'Tonic', desc: 'Fortifies all cores' },
  { id: 'g_oil', shop: 'general', name: 'Gun Oil', price: 1.50, gold: 0, rank: 1, type: 'Maintenance', desc: 'Clean weapons' },

  // --- MADAM NAZAR ---
  { id: 'n_shovel', shop: 'nazar', name: 'Pennington Field Shovel', price: 350.00, gold: 0, rank: 1, role: 'Collector', tokens: 0, type: 'Tool', desc: 'Digs up buried items' },
  { id: 'n_detector', shop: 'nazar', name: 'Metal Detector', price: 700.00, gold: 0, rank: 5, role: 'Collector', tokens: 2, type: 'Tool', desc: 'Finds coins and jewelry' },
  { id: 'n_binoculars', shop: 'nazar', name: 'Refined Binoculars', price: 450.00, gold: 0, rank: 5, role: 'Collector', tokens: 2, type: 'Tool', desc: 'Highlights dig sites' },

  // --- ROLE VENDORS (Wilderness Outfitters / Maggie) ---
  { id: 'r_fast_travel', shop: 'roles', name: 'Fast Travel Post', price: 700.00, gold: 0, rank: 65, type: 'Camp', desc: 'Travel from wilderness camp' },
  { id: 'r_bounty_wagon', shop: 'roles', name: 'Bounty Wagon', price: 875.00, gold: 0, rank: 10, role: 'Bounty Hunter', tokens: 2, type: 'Vehicle', desc: 'Secure transport' },
  { id: 'r_hunting_wagon', shop: 'roles', name: 'Hunting Wagon', price: 875.00, gold: 0, rank: 10, role: 'Trader', tokens: 2, type: 'Vehicle', desc: 'Carries 5 large carcasses' },
  { id: 'r_large_wagon', shop: 'roles', name: 'Large Delivery Wagon', price: 750.00, gold: 0, rank: 10, role: 'Trader', tokens: 2, type: 'Vehicle', desc: 'Max sale size' },
  { id: 'r_still_condenser', shop: 'roles', name: 'Condenser Upgrade', price: 825.00, gold: 0, rank: 5, role: 'Moonshiner', tokens: 2, type: 'Upgrade', desc: 'Average strength shine' },
  { id: 'r_still_pol', shop: 'roles', name: 'Polished Copper Upgrade', price: 875.00, gold: 0, rank: 10, role: 'Moonshiner', tokens: 3, type: 'Upgrade', desc: 'Strong shine' }
];

export default MASTER_CATALOG;

/**
 * ==============================================================================
 * RDO UNIFIED SCHEMA v3.0
 * Complete TypeScript/JSDoc interface definitions for the entire system
 * ==============================================================================
 *
 * This schema represents the canonical data structure for:
 * - Catalog items (weapons, horses, consumables)
 * - Animals (predators, herbivores, legendary)
 * - Economic formulas (reverse-engineered from game)
 * - Geographic data (fast travel, regions, spawns)
 * - Role progression (unlock chains, prerequisites)
 * - Data quality (confidence tiers, sources, versioning)
 *
 * All interfaces include JSDoc examples for clarity.
 */

// ==============================================================================
// 1. DATA QUALITY INTERFACES
// ==============================================================================

/**
 * @typedef {Object} DataSource
 * @property {'GAME_TEST'|'REDDIT'|'WIKI'|'YOUTUBE'|'COMMUNITY_TESTED'} type
 * @property {string} date ISO 8601 date (YYYY-MM-DD)
 * @property {string} [verified_by] Player or researcher who verified
 * @property {string} [url] Link to source
 * @property {string} [notes] Additional context
 *
 * @example
 * {
 *   type: 'GAME_TEST',
 *   date: '2025-11-20',
 *   verified_by: 'Professional1994',
 *   notes: 'Confirmed in-game using multiple test runs'
 * }
 */

/**
 * @typedef {'HIGH'|'MEDIUM'|'LOW'} ConfidenceLevel
 * HIGH: Verified by multiple independent sources, in-game tested
 * MEDIUM: Verified by one source, community consensus
 * LOW: Estimated, anecdotal, awaiting confirmation
 */

/**
 * @typedef {Object} DataQuality
 * @property {ConfidenceLevel} confidence
 * @property {DataSource[]} sources
 * @property {string} last_verified ISO 8601 date when last confirmed
 * @property {string} [patch_version] RDO patch version this is valid for
 * @property {string} [deprecation_warning] If null, data is current
 *
 * @example
 * {
 *   confidence: 'HIGH',
 *   sources: [
 *     { type: 'GAME_TEST', date: '2025-11-20', verified_by: 'Professional1994' },
 *     { type: 'REDDIT', date: '2025-11-19', url: 'reddit.com/...' }
 *   ],
 *   last_verified: '2025-11-20',
 *   patch_version: '1.29.0'
 * }
 */

// ==============================================================================
// 2. CATALOG ITEM INTERFACES
// ==============================================================================

/**
 * @typedef {Object} RDOItem
 * @property {string} id Unique identifier (snake_case)
 * @property {string} name Display name
 * @property {string} [description] Detailed description
 * @property {'weapon'|'horse'|'tack'|'clothing'|'consumable'|'tool'|'upgrade'|'vehicle'} type
 * @property {'gunsmith'|'stable'|'tailor'|'fence'|'general'|'nazar'|'roles'|'harriet'} shop Which vendor sells it
 *
 * @property {number} price Cash price (0 if gold-only)
 * @property {number} gold_cost Gold bar cost (0 if cash-only)
 * @property {number} [tokens] Role tokens required (0 if not applicable)
 * @property {number} rank_required Minimum character rank to purchase
 * @property {string} [role_required] If role-gated (e.g., 'trader', 'collector')
 * @property {number} [role_rank_required] Minimum role level required
 *
 * @property {number} meta_score 1-10 ranking of usefulness
 * @property {string} meta_reason Why this item is valued
 * @property {string} [opportunity_cost] What else could you buy instead?
 * @property {Object} [hidden_stats] Non-visible game properties
 * @property {string[]} [unlocks] What this item enables
 *
 * @property {DataQuality} data_quality
 *
 * @example
 * {
 *   id: 'w_navy',
 *   name: 'Navy Revolver',
 *   type: 'weapon',
 *   shop: 'gunsmith',
 *   price: 275.00,
 *   gold_cost: 0,
 *   rank_required: 1,
 *   meta_score: 9,
 *   meta_reason: 'Highest DPS sidearm, best for PvP',
 *   opportunity_cost: 'Schofield Revolver ($192) for slower but more accurate shots',
 *   hidden_stats: {
 *     bloom_shrink_rate: 0.12,
 *     recoil_bloom: 0.08
 *   },
 *   unlocks: ['dual_wield_capability'],
 *   data_quality: { confidence: 'HIGH', sources: [...], last_verified: '2025-11-20' }
 * }
 */

/**
 * @typedef {Object} HorseData
 * @extends RDOItem
 * @property {number} speed 1-10 rating
 * @property {number} health 1-10 rating
 * @property {number} stamina 1-10 rating
 * @property {number} acceleration 1-10 rating
 * @property {string} [breed] Horse breed classification
 * @property {boolean} is_legendary True for epilogue legendary horses
 *
 * @example
 * {
 *   id: 'h_arabian_black',
 *   name: 'Black Arabian',
 *   type: 'horse',
 *   price: 0,
 *   gold_cost: 42,
 *   rank_required: 70,
 *   meta_score: 10,
 *   speed: 9,
 *   health: 9,
 *   stamina: 9,
 *   acceleration: 9,
 *   breed: 'Arabian',
 *   meta_reason: 'Elite handling + max stats, but 42 GB is prohibitive for new players'
 * }
 */

/**
 * @typedef {Object} WeaponData
 * @extends RDOItem
 * @property {'sidearm'|'longarm'|'melee'} weapon_class
 * @property {number} damage 1-100 visible rating
 * @property {number} range 1-100 visible rating
 * @property {number} accuracy 1-100 visible rating
 * @property {number} fire_rate 1-100 visible rating
 * @property {Object} hidden_stats
 * @property {number} hidden_stats.bloom_shrink_rate Affects consecutive shot accuracy
 * @property {number} hidden_stats.recoil_bloom Initial recoil spread
 * @property {number} hidden_stats.reload_frames Frames to reload (governs DPS)
 *
 * @example
 * {
 *   id: 'w_carcano',
 *   name: 'Carcano Rifle',
 *   type: 'weapon',
 *   weapon_class: 'longarm',
 *   price: 456.00,
 *   rank_required: 50,
 *   damage: 92,
 *   range: 99,
 *   accuracy: 95,
 *   fire_rate: 20,
 *   hidden_stats: {
 *     bloom_shrink_rate: 0.08,
 *     recoil_bloom: 0.05,
 *     reload_frames: 120
 *   },
 *   meta_score: 10,
 *   meta_reason: 'Meta sniper for PvP and legendary animals'
 * }
 */

// ==============================================================================
// 3. ANIMAL INTERFACES
// ==============================================================================

/**
 * @typedef {Object} AnimalSpawn
 * @property {number} latitude Map coordinate
 * @property {number} longitude Map coordinate
 * @property {string} region_id Reference to region
 * @property {number} spawn_probability 0.0-1.0 (e.g., 0.85 = 85% chance)
 * @property {string} [time_window] e.g., '10 PM - 5 AM' if time-restricted
 * @property {string} [season] 'spring'|'summer'|'fall'|'winter' if season-dependent
 * @property {string} [weather] 'rain'|'clear'|'snow' if weather-dependent
 *
 * @example
 * {
 *   latitude: -32.4,
 *   longitude: 78.2,
 *   region_id: 'west_elizabeth',
 *   spawn_probability: 0.85,
 *   season: 'any'
 * }
 */

/**
 * @typedef {Object} Animal
 * @property {string} id Unique identifier
 * @property {string} name Display name
 * @property {'predator'|'herbivore'|'small_game'|'legendary'} category
 * @property {string} species Scientific or common classification
 *
 * @property {Object} hunting_data
 * @property {number} hunting_data.perfect_pelt_value Cash from selling perfect pelt to butcher
 * @property {number} hunting_data.perfect_pelt_count How many parts make a perfect pelt
 * @property {number} hunting_data.material_value_base Cripps donation value (base)
 * @property {number} hunting_data.material_value_with_efficiency Cripps donation value (Rank 11 perk)
 * @property {number} hunting_data.estimated_hunt_minutes Time to find and kill
 * @property {string} hunting_data.recommended_weapon Best weapon type
 * @property {string} hunting_data.best_approach 'headshot'|'poison'|'rifle'|'other'
 *
 * @property {AnimalSpawn[]} spawn_locations
 *
 * @property {Object} naturalist_data (if legendary)
 * @property {number} naturalist_data.study_phases How many times to study
 * @property {number} naturalist_data.material_value Legendary material bomb value
 * @property {boolean} naturalist_data.requires_sedate_or_kill
 *
 * @property {DataQuality} data_quality
 *
 * @example
 * {
 *   id: 'cougar',
 *   name: 'Cougar',
 *   category: 'predator',
 *   species: 'Felis concolor',
 *   hunting_data: {
 *     perfect_pelt_value: 5.00,
 *     material_value_base: 13.50,
 *     material_value_with_efficiency: 16.88,
 *     estimated_hunt_minutes: 15,
 *     recommended_weapon: 'Rifle (Bolt Action or better)',
 *     best_approach: 'headshot'
 *   },
 *   spawn_locations: [
 *     { latitude: -32.4, longitude: 78.2, region_id: 'west_elizabeth', spawn_probability: 0.85 }
 *   ],
 *   data_quality: { confidence: 'HIGH', ... }
 * }
 */

/**
 * @typedef {Object} LegendaryAnimal
 * @extends Animal
 * @property {number} material_bomb_value Cripps donation value (e.g., 62.50)
 * @property {string} pelt_rarity 'common'|'rare'|'legendary'
 * @property {number} naturalist_study_reward XP from studying
 * @property {number} naturalist_study_phases Phases to complete study
 * @property {string} specific_spawn_condition e.g., "Only appears during specific mission" or "Random spawn"
 * @property {string} cooldown_period e.g., "48-minute cooldown after capture"
 *
 * @example
 * {
 *   id: 'golden_spirit_bear',
 *   name: 'Golden Spirit Bear',
 *   category: 'legendary',
 *   material_bomb_value: 62.50,
 *   pelt_rarity: 'legendary',
 *   naturalist_study_phases: 3,
 *   specific_spawn_condition: 'Random spawn in Big Valley/Tall Trees'
 * }
 */

// ==============================================================================
// 4. ECONOMIC FORMULA INTERFACES
// ==============================================================================

/**
 * @typedef {Object} EconomicFormula
 * @property {string} id Unique identifier
 * @property {string} name Display name
 * @property {string} role Which role uses this formula ('bounty_hunter', 'trader', etc.)
 * @property {string} formula Mathematical formula (e.g., "P = B Ã— M_tier Ã— M_status Ã— M_time")
 * @property {Object.<string, Object>} variables Map of variable definitions
 * @property {Object[]} examples Concrete calculation examples
 * @property {number} [efficiency_rating] Profit per hour this formula generates
 * @property {DataQuality} data_quality
 *
 * @example
 * {
 *   id: 'bounty_cash_payout',
 *   name: 'Bounty Hunter Cash Payout',
 *   role: 'bounty_hunter',
 *   formula: 'P = B Ã— M_tier Ã— M_status Ã— M_time Ã— M_count',
 *   variables: {
 *     B: { description: 'Base Cash', standard_value: 30.00 },
 *     M_tier: { description: 'Tier Multiplier', values: { '1_star': 1.0, '2_star': 1.25, '3_star': 1.5 } },
 *     M_status: { description: 'Status (Alive=1.0, Dead=0.5)' },
 *     M_time: { description: 'Time-based multiplier', note: 'Increases with mission duration' },
 *     M_count: { description: 'Target count', values: { '1': 1.0, '2': 1.67, '4+': 2.0 } }
 *   },
 *   examples: [
 *     {
 *       description: '3-star bounty, alive, 12 minutes',
 *       inputs: { B: 30, tier: 1.5, status: 1.0, time: 12, count: 1 },
 *       output: 78.75,
 *       calculation_steps: [
 *         'Base: $30.00',
 *         'Tier 3: 30 Ã— 1.5 = $45.00',
 *         'Alive bonus: 45 Ã— 1.0 = $45.00',
 *         'Time (12 min): 45 Ã— 1.75 = $78.75'
 *       ]
 *     }
 *   ],
 *   data_quality: { confidence: 'HIGH', ... }
 * }
 */

/**
 * @typedef {Object} GoldPayoutFunction
 * @property {number} minutes_elapsed
 * @property {number} gold_earned
 * @property {number} rate_gold_per_minute
 * @property {string} [note] Context note (e.g., "Peak efficiency point")
 *
 * @example
 * { minutes_elapsed: 12, gold_earned: 0.32, rate: 0.026, note: 'Peak efficiency (12-min meta)' }
 */

// ==============================================================================
// 5. GEOGRAPHIC INTERFACES
// ==============================================================================

/**
 * @typedef {Object} FastTravelNode
 * @property {string} id Unique identifier
 * @property {string} name Display name
 * @property {number} latitude Map coordinate
 * @property {number} longitude Map coordinate
 * @property {string} [region_id] Which region this node serves
 * @property {boolean} is_player_camp True if player's main camp
 * @property {boolean} is_wilderness_camp True if temporary camp
 * @property {boolean} unlockable True if requires unlock (e.g., Fast Travel Post)
 * @property {number} [unlock_cost] If unlockable
 *
 * @example
 * {
 *   id: 'valentine',
 *   name: 'Valentine',
 *   latitude: 44.5,
 *   longitude: -73.2,
 *   region_id: 'the_heartlands',
 *   is_player_camp: false,
 *   unlockable: false
 * }
 */

/**
 * @typedef {Object} FastTravelRoute
 * @property {string} origin_id From node
 * @property {string} destination_id To node
 * @property {number} distance_miles Euclidean distance
 * @property {number} cost_standard Standard fast travel cost
 * @property {number} [cost_wilderness_camp_exploit] Cost using wilderness camp trick ($1 typically)
 * @property {number} savings Difference if using exploit
 * @property {string} [note] Any special information
 *
 * @example
 * {
 *   origin_id: 'valentine',
 *   destination_id: 'annesburg',
 *   distance_miles: 145.65,
 *   cost_standard: 12.00,
 *   cost_wilderness_camp_exploit: 3.00,
 *   savings: 9.00,
 *   note: 'Capped at $12 max despite distance'
 * }
 */

/**
 * @typedef {Object} Region
 * @property {string} id Unique identifier
 * @property {string} name Display name
 * @property {string} biome 'forest'|'grassland'|'desert'|'swamp'|'mountains'|'urban'
 * @property {string[]} animal_ids Animals found in this region
 * @property {string[]} fast_travel_node_ids Nearby fast travel posts
 * @property {number} danger_level 1-10 (NPC encounters, bandits)
 * @property {string} optimal_for Description of best activities
 * @property {number} average_profit_per_hour Estimated income for typical hunting
 *
 * @example
 * {
 *   id: 'west_elizabeth',
 *   name: 'West Elizabeth',
 *   biome: 'forest',
 *   animal_ids: ['cougar', 'puma', 'elk', 'boar'],
 *   fast_travel_node_ids: ['valentine', 'strawberry'],
 *   danger_level: 6,
 *   optimal_for: 'Hunting (predators, top-tier pelts)',
 *   average_profit_per_hour: 187.50
 * }
 */

// ==============================================================================
// 6. ROLE & PROGRESSION INTERFACES
// ==============================================================================

/**
 * @typedef {Object} Role
 * @property {string} id Unique identifier
 * @property {string} name Display name
 * @property {number} unlock_rank Character rank required
 * @property {number} unlock_cost_cash Cash cost to unlock
 * @property {number} unlock_cost_gold Gold cost to unlock
 * @property {string[]} [prerequisites] Other roles required first
 * @property {number} max_rank Maximum role level
 * @property {string} description Role summary
 * @property {Object} rewards_per_rank What you get per level
 * @property {string[]} abilities Unlocked abilities
 * @property {string[]} tools Starter tools
 * @property {string} playstyle 'active'|'passive'|'hybrid'
 * @property {number} estimated_profit_per_hour Average income
 *
 * @example
 * {
 *   id: 'trader',
 *   name: 'Trader',
 *   unlock_rank: 5,
 *   unlock_cost_cash: 0,
 *   unlock_cost_gold: 15,
 *   prerequisites: [],
 *   max_rank: 20,
 *   description: 'Hunt animals and donate materials to produce and sell goods',
 *   playstyle: 'passive',
 *   estimated_profit_per_hour: 187.50
 * }
 */

/**
 * @typedef {Object} PrerequisiteChain
 * @property {string} target_item_id The item you want to unlock
 * @property {Object[]} requirements What you need
 * @property {number} total_hours_to_unlock Estimated time
 * @property {string[]} recommended_activities Activities to complete it
 *
 * @example
 * {
 *   target_item_id: 'moonshiner_license',
 *   requirements: [
 *     { type: 'character_rank', current: 5, needed: 5 },
 *     { type: 'gold', current: 5, needed: 25 },
 *     { type: 'role_unlock', role: 'trader', current: false, needed: true },
 *     { type: 'role_rank', role: 'trader', current: 0, needed: 5 }
 *   ],
 *   total_hours_to_unlock: 8,
 *   recommended_activities: ['Bounty hunts for gold', 'Collect for cash']
 * }
 */

// ==============================================================================
// 7. SIMULATION & STATS INTERFACES
// ==============================================================================

/**
 * @typedef {Object} PlayerStats
 * @property {number} rank Character level (1-100+)
 * @property {number} xp Current XP in rank
 * @property {number} xp_to_next_rank XP needed for next level
 * @property {number} cash Available RDO$
 * @property {number} gold Available Gold Bars
 * @property {number} tokens Available Role Tokens
 * @property {Object.<string, number>} role_ranks { trader: 5, collector: 10, ... }
 * @property {Object.<string, number>} role_xp { trader: 500, ... }
 * @property {string[]} owned_items Item IDs player has purchased
 * @property {number} playtime_hours Total hours played
 *
 * @example
 * {
 *   rank: 47,
 *   xp: 3279,
 *   xp_to_next_rank: 2000,
 *   cash: 1466.00,
 *   gold: 9.20,
 *   tokens: 25,
 *   role_ranks: { trader: 20, collector: 4, bounty_hunter: 7, moonshiner: 4 },
 *   owned_items: ['w_navy', 'w_bolt', 'h_mustang_buck'],
 *   playtime_hours: 250
 * }
 */

/**
 * @typedef {Object} SimulationState
 * @property {PlayerStats} base_stats Actual character stats
 * @property {Object} sim_adjustments What player is testing
 * @property {number} sim_adjustments.cash_bonus Added cash
 * @property {number} sim_adjustments.gold_bonus Added gold
 * @property {number} sim_adjustments.rank_boost Simulated ranks gained
 * @property {string[]} projected_purchases Items player is considering
 * @property {Object} projected_costs Totals for projected purchases
 * @property {boolean} is_affordable Can afford everything?
 *
 * @example
 * {
 *   base_stats: { rank: 47, cash: 1466.00, ... },
 *   sim_adjustments: { cash_bonus: 500, gold_bonus: 10 },
 *   projected_purchases: ['metal_detector', 'binoculars'],
 *   projected_costs: { cash: 1150, gold: 2 },
 *   is_affordable: true
 * }
 */

// ==============================================================================
// 8. COLLECTION INTERFACES
// ==============================================================================

/**
 * @typedef {Object} CollectorSet
 * @property {string} id Unique identifier
 * @property {string} name Display name
 * @property {number} total_items How many items in complete set
 * @property {number} completion_value Cash for selling complete set
 * @property {number} completion_xp XP for completing set
 * @property {number} cycle_count How many cycles (6 typical)
 * @property {string} [tool_required] e.g., 'metal_detector' if needed
 * @property {Object[]} locations All item locations by cycle
 * @property {DataQuality} data_quality
 *
 * @example
 * {
 *   id: 'tarot_cards',
 *   name: 'Tarot Cards',
 *   total_items: 14,
 *   completion_value: 240.50,
 *   completion_xp: 1500,
 *   cycle_count: 6,
 *   tool_required: null,
 *   locations: [
 *     { set_name: 'tarot_cards', item_id: 't1', name: 'The Fool', cycle: 1, latitude: ..., longitude: ... }
 *   ]
 * }
 */

// ==============================================================================
// SUMMARY: USAGE GUIDELINES
// ==============================================================================

/**
 * How to use these schemas:
 *
 * 1. VALIDATION:
 *    - Use JSDoc types to validate objects at runtime
 *    - Example: const item = validateItem(data) using instanceof or custom validator
 *
 * 2. REDUX STATE:
 *    - Each interface maps to a slice: catalogSlice, animalSlice, etc.
 *    - State structure mirrors schema: state.catalog.items[id], state.animals.all[id]
 *
 * 3. DATA FILES:
 *    - JSON files contain arrays of these objects
 *    - Example: /src/data/catalog/weapons.json contains WeaponData[]
 *
 * 4. SELECTORS:
 *    - Create memoized selectors to query these objects
 *    - Example: selectItemsByShop(state, shopId) returns RDOItem[]
 *
 * 5. FORMULAS:
 *    - EconomicFormula objects are documents, not code
 *    - Separate calculator functions implement the math
 *    - Example: calculateBountyCash(formula, inputs) uses formula fields
 *
 * 6. CONFIDENCE TIERS:
 *    - EVERY object has DataQuality with confidence level
 *    - Filter UI by confidence: "Show only HIGH confidence data"
 *    - Track: Last verified date, sources, warnings
 *
 * 7. GEOGRAPHIC DATA:
 *    - Coordinates are Euclidean (distance-based), not lat/long
 *    - Used for fast travel cost matrix and animal spawns
 *    - Route optimization uses TSP (Traveling Salesman Problem)
 */

export const SCHEMA_VERSION = '3.0.0';
export const SCHEMA_LAST_UPDATED = '2025-12-03';

/**
 * FALLBACK DATA - Minimal dataset used when migration fails
 * 
 * This ensures the app always has something to display,
 * preventing blank screens even if the database is corrupted.
 */

import type { RDOItem } from './rdo_unified_schema';

export const FALLBACK_ITEMS: RDOItem[] = [
  {
    id: 'navy_revolver',
    name: 'Navy Revolver',
    type: 'Revolver',
    price: {
      value: 275.0,
      confidence: 'HIGH',
      sources: [],
      last_verified: new Date().toISOString(),
    },
    required_rank: 0,
    description: 'Standard issue sidearm',
  },
  {
    id: 'springfield_rifle',
    name: 'Springfield Rifle',
    type: 'Rifle',
    price: {
      value: 355.0,
      confidence: 'HIGH',
      sources: [],
      last_verified: new Date().toISOString(),
    },
    required_rank: 5,
    description: 'Reliable hunting rifle',
  },
  {
    id: 'schofield_revolver',
    name: 'Schofield Revolver',
    type: 'Revolver',
    price: {
      value: 450.0,
      confidence: 'HIGH',
      sources: [],
      last_verified: new Date().toISOString(),
    },
    required_rank: 10,
    description: 'Quick reload mechanism',
  },
  {
    id: 'volcanic_pistol',
    name: 'Volcanic Pistol',
    type: 'Pistol',
    price: {
      value: 490.0,
      confidence: 'MEDIUM',
      sources: [],
      last_verified: new Date().toISOString(),
    },
    required_rank: 15,
    description: 'Heavy damage sidearm',
  },
  {
    id: 'cattleman_revolver',
    name: 'Cattleman Revolver',
    type: 'Revolver',
    price: {
      value: 300.0,
      confidence: 'HIGH',
      sources: [],
      last_verified: new Date().toISOString(),
    },
    required_rank: 0,
    description: 'Classic revolver',
  },
];

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * GAME DATA CONSTANTS - Extracted Static Values
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * Hardcoded values derived from Frontier Algorithm and verified sources.
 * These form the "foundation layer" of economic calculations.
 * 
 * Each constant includes:
 * - The value
 * - A comment with source/date
 * - Usage context (which calculators use it)
 */

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ROLE UNLOCK COSTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export const ROLE_UNLOCK_COSTS = {
  trader: {
    gold: 15.0,           // Verified: GAME_TEST 2025-11-20
    player_rank_required: 5,
  },
  moonshiner: {
    gold: 25.0,           // Verified: GAME_TEST 2025-11-20
    player_rank_required: 5,
  },
  bounty_hunter: {
    gold: 15.0,           // Verified: GAME_TEST 2025-11-20
    player_rank_required: 5,
  },
  collector: {
    gold: 15.0,           // Verified: WIKI 2025-11-15
    player_rank_required: 5,
  },
  naturalist: {
    gold: 25.0,           // Verified: GAME_TEST 2025-11-18
    player_rank_required: 5,
  },
} as const;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BOUNTY HUNTER - Payout Structure
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Base cash payout for single-target bounties.
 * Source: FRONTIER_ALGORITHM + GAME_TEST verification
 * Used by: calculateBountyPayout()
 */
export const BOUNTY_PAYOUT_BASE_CASH = 30;

/**
 * Tier multipliers for bounty difficulty.
 * $    = 1 star   = 1.0x
 * $$   = 2 stars  = 1.25x
 * $$$ = 3 stars  = 1.5x
 * Source: FRONTIER_ALGORITHM verified 2025-11-10
 */
export const BOUNTY_PAYOUT_TIER_MULTIPLIERS = {
  1: 1.0,
  2: 1.25,
  3: 1.5,
} as const;

/**
 * Status multiplier: alive vs dead target
 * Alive bonus = 1.0x
 * Dead penalty = 0.5x
 * Source: FRONTIER_ALGORITHM verified 2025-11-10
 */
export const BOUNTY_PAYOUT_STATUS_MULTIPLIERS = {
  alive: 1.0,
  dead: 0.5,
} as const;

/**
 * Target count multipliers (multi-target bounties)
 * 1 target = 1.0x
 * 2 targets = 5/3 â‰ˆ 1.667x
 * 3 targets = 2.0x (capped at 3 max)
 * Source: FRONTIER_ALGORITHM 2025-11-05
 */
export const BOUNTY_PAYOUT_TARGET_MULTIPLIERS = {
  1: 1.0,
  2: 5 / 3,  // 1.667
  3: 2.0,
} as const;

/**
 * Gold step function for time bonus.
 * Grants 0.08 gold per 3 minutes (0-12 min window = up to 0.32 gold)
 * Then diminishing returns:
 *   12-15 min: 0.04 gold
 *   15-30 min: 0.04 per 5 min increments
 * Source: FRONTIER_ALGORITHM 2025-11-01 (matches in-game observations)
 */
export const BOUNTY_GOLD_TIME_BONUS = {
  base_increment: 0.08,        // per 3 minutes
  window_minutes: 3,
  optimal_duration_minutes: 12,
  optimal_gold: 0.32,
  post_optimal_increment: 0.04,
  post_optimal_window: 5,
} as const;

/**
 * XP base values for bounties.
 * Exact multipliers pending verification.
 */
export const BOUNTY_XP_BASE = {
  cash_kill: 50,               // XP for cash-based kill
  ranked_kill: 100,            // XP for ranked bounties
} as const;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TRADER - Material â†’ Goods â†’ Payout
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Material payout values (sold to general store, not through Cripps).
 * Source: GAME_TEST 2025-11-15
 */
export const TRADER_MATERIAL_PAYOUTS = {
  deer_pelt_perfect: 4.5,
  cougar_pelt_perfect: 12.5,
  wolf_pelt_perfect: 8.0,
  alligator_skin_perfect: 10.0,
  panther_pelt_perfect: 25.0,
} as const;

/**
 * Goods value per unit delivered to buyers.
 * 100 goods = $625 + time bonus (up to $75)
 * Source: FRONTIER_ALGORITHM verified 2025-11-08
 */
export const TRADER_GOODS_CONVERSION = {
  goods_per_unit_sold: 1,
  base_payout_per_100_goods: 625,  // Without time bonus
  max_time_bonus: 75,               // If delivered within 30 min
  max_distance_bonus: 50,           // If destination is far (rare)
} as const;

/**
 * Wagon size â†’ goods capacity
 */
export const TRADER_WAGON_CAPACITY = {
  small: 50,
  large: 100,
} as const;

/**
 * Material gathering efficiency (typical sessions).
 * Assumes optimal hunt + material yield + no waste.
 */
export const TRADER_SESSION_EFFICIENCY = {
  avg_materials_per_hour: 30,  // Typically 3-5 kills per bounty loop
  materials_to_goods_ratio: 1, // 1 material = 1 goods (simplified)
} as const;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MOONSHINER - Batch Profit Matrix
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Base batch profit by mash type (before time, distance, mood multipliers).
 * Source: FRONTIER_ALGORITHM 2025-10-28
 */
export const MOONSHINER_BASE_BATCH_PROFIT = {
  corn: 48.75,
  rye: 52.50,
  wheat: 56.25,
  sugar: 60.00,
  agave: 65.00,
} as const;

/**
 * Time bonus structure for selling batches.
 * Optimal window: 2-4 hours of aging â†’ 1.25x multiplier
 * Beyond 4 hours: 1.0x (no additional bonus, but less flavor penalty)
 */
export const MOONSHINER_TIME_BONUS = {
  min_age_hours: 2,
  max_age_hours: 4,
  optimal_multiplier: 1.25,
  beyond_optimal_multiplier: 1.0,
} as const;

/**
 * Distance bonus (delivery location).
 * Farther = more money (incentivizes risk/effort)
 */
export const MOONSHINER_DISTANCE_BONUS = {
  nearby: 1.0,      // Nearby safe buyer
  medium: 1.1,      // Further into wilderness
  far: 1.25,        // Rival gang territory or remote
} as const;

/**
 * Mood multipliers for shack ambiance/decor (future expansion).
 * Currently all batches assume neutral mood (1.0x).
 */
export const MOONSHINER_MOOD_MULTIPLIER = {
  poor: 0.8,
  neutral: 1.0,
  good: 1.1,
  excellent: 1.2,
} as const;

/**
 * Shack upgrade levels and their profit multipliers.
 */
export const MOONSHINER_SHACK_LEVELS = {
  1: { cost: 0, profit_multiplier: 1.0 },
  2: { cost: 50, profit_multiplier: 1.05 },
  3: { cost: 100, profit_multiplier: 1.1 },
  4: { cost: 100, profit_multiplier: 1.15 },
} as const;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COLLECTOR - Item Economics
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Base payout per collector item (varies by set + cycle).
 * Average across all sets: ~$2-3 per item
 * Complete set bonus: $10-20 depending on set
 * Source: JEANROPKE_MAP + GAME_TEST 2025-11-12
 */
export const COLLECTOR_PAYOUT_BY_SET = {
  tarot_cards: {
    per_card: 2.5,
    complete_set_bonus: 15.0,
    total_per_cycle: 22.5 + 15,  // 10 cards
  },
  coins: {
    per_coin: 3.0,
    complete_set_bonus: 20.0,
    total_per_cycle: 42 + 20,     // 14 coins
  },
  flowers: {
    per_flower: 3.5,
    complete_set_bonus: 20.0,
    total_per_cycle: 35 + 20,     // 10 flowers
  },
  lost_gang_hideout_items: {
    per_item: 4.0,
    complete_set_bonus: 25.0,
    total_per_cycle: 24 + 25,     // 6 items
  },
} as const;

/**
 * Average collection time per item (including travel).
 * Varies by set difficulty and region spread.
 */
export const COLLECTOR_TIME_PER_ITEM_MINUTES = {
  tarot_cards: 3,       // Relatively compact spawn area
  coins: 5,             // Spread across map
  flowers: 4,           // Moderate spread
  lost_gang_hideout_items: 6,  // Most spread out
} as const;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NATURALIST - Study Payouts
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Cash + RDO$ per animal studied to Harriet Davenport.
 * Source: GAME_TEST 2025-11-18
 */
export const NATURALIST_STUDY_PAYOUT = {
  small_animal: { cash: 4.5, gold: 0.02 },
  large_animal: { cash: 8.0, gold: 0.04 },
  legendary_animal: { cash: 25.0, gold: 0.10 },
} as const;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FAST TRAVEL - Cost Structure
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Base fast travel costs (camp â†’ destination).
 * Note: Some routes are asymmetric (e.g., Saint Denis â†’ Strawberry differs from reverse).
 * Source: GAME_TEST + WIKI 2025-11-10
 */
export const FAST_TRAVEL_BASE_COSTS = {
  short_distance: 3.75,   // <10 miles
  medium_distance: 5.0,   // 10-25 miles
  long_distance: 7.5,     // 25+ miles
} as const;

/**
 * Special fast travel cost tiers (main towns).
 */
export const FAST_TRAVEL_FIXED_COSTS = {
  valentine: 5.0,
  saint_denis: 5.0,
  strawberry: 3.75,
  emerald_station: 3.75,
} as const;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PLAYER PROGRESSION - Rank XP Curve
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * XP required per rank level (simplified cubic curve).
 * Pending detailed verification from GAME_TEST.
 * Current values are placeholder based on typical RPG patterns.
 */
export const RANK_XP_CURVE = {
  base_multiplier: 100,
  curve_exponent: 1.3,  // Cubic-ish growth

  // Precomputed for ranks 1-500 (simplified lookup)
  // In production, use: XP_for_rank = base * (rank ^ exponent)
} as const;

/**
 * Ability card unlock schedule.
 * Pending detailed mapping from in-game testing.
 */
export const ABILITY_CARD_UNLOCK_RANKS = {
  // Placeholder; fill in after testing
  Dead_Eye_Basics: 3,
  Gunslinger_Techniques: 10,
  // ... (add others)
} as const;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COLLECTION CYCLES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Collector set definitions + cycle counts.
 * Each set has 1-3 cycles; items rotate per cycle.
 * Source: JEANROPKE_MAP + COMMUNITY_TESTED 2025-11-15
 */
export const COLLECTION_SETS = {
  tarot_cards: {
    item_count: 10,
    cycle_count: 3,
    bonus_cash_per_set: 15.0,
  },
  coins: {
    item_count: 14,
    cycle_count: 3,
    bonus_cash_per_set: 20.0,
  },
  flowers: {
    item_count: 10,
    cycle_count: 3,
    bonus_cash_per_set: 20.0,
  },
  lost_gang_hideout_items: {
    item_count: 6,
    cycle_count: 1,         // Single cycle
    bonus_cash_per_set: 25.0,
  },
} as const;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SIMULATION DEFAULTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Default player state for simulations (e.g., "beginner" profile).
 * Used when user hasn't logged in or wants a fresh sandbox.
 */
export const DEFAULT_PLAYER_PROFILE = {
  rank: 10,
  cash: 250,
  gold_bars: 5,
  roles_owned: [],
  trader_rank: 0,
  moonshiner_rank: 0,
  bounty_hunter_rank: 0,
  collector_rank: 0,
  naturalist_rank: 0,
} as const;

/**
 * Intermediate player profile (mid-game, all roles unlocked).
 */
export const INTERMEDIATE_PLAYER_PROFILE = {
  rank: 75,
  cash: 5000,
  gold_bars: 50,
  roles_owned: ['trader', 'moonshiner', 'bounty_hunter', 'collector', 'naturalist'],
  trader_rank: 10,
  moonshiner_rank: 10,
  bounty_hunter_rank: 10,
  collector_rank: 5,
  naturalist_rank: 5,
} as const;

/**
 * Advanced player profile (endgame, optimized).
 */
export const ADVANCED_PLAYER_PROFILE = {
  rank: 500,
  cash: 100000,
  gold_bars: 500,
  roles_owned: ['trader', 'moonshiner', 'bounty_hunter', 'collector', 'naturalist'],
  trader_rank: 20,
  moonshiner_rank: 20,
  bounty_hunter_rank: 20,
  collector_rank: 20,
  naturalist_rank: 20,
} as const;

export default {
  ROLE_UNLOCK_COSTS,
  BOUNTY_PAYOUT_BASE_CASH,
  BOUNTY_PAYOUT_TIER_MULTIPLIERS,
  BOUNTY_PAYOUT_STATUS_MULTIPLIERS,
  BOUNTY_PAYOUT_TARGET_MULTIPLIERS,
  BOUNTY_GOLD_TIME_BONUS,
  TRADER_MATERIAL_PAYOUTS,
  TRADER_GOODS_CONVERSION,
  TRADER_WAGON_CAPACITY,
  MOONSHINER_BASE_BATCH_PROFIT,
  MOONSHINER_TIME_BONUS,
  COLLECTOR_PAYOUT_BY_SET,
  COLLECTION_SETS,
  FAST_TRAVEL_BASE_COSTS,
  DEFAULT_PLAYER_PROFILE,
  INTERMEDIATE_PLAYER_PROFILE,
  ADVANCED_PLAYER_PROFILE,
};

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * RDO UNIFIED SCHEMA - THE KNOWLEDGE LAYER CONTRACT
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * This file defines all types for the RDO knowledge layer (compendium).
 * Every piece of static game data must conform to these shapes.
 * 
 * Key principle: VersionedValue<T> wraps all domain data with confidence,
 * sources, and verification dates. This enables crowd-sourced truth-seeking
 * while maintaining data integrity.
 */

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONFIDENCE & SOURCE TRACKING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export type Confidence = 'HIGH' | 'MEDIUM' | 'LOW';

export type DataSource = 
  | 'GAME_TEST'           // Verified in-game by trusted tester
  | 'REDDIT'              // Reddit discussion thread
  | 'WIKI'                // Red Dead Wiki
  | 'YOUTUBE'             // YouTube guide / testing video
  | 'JEANROPKE_MAP'       // Jeanropke RDO map data
  | 'FRONTIER_ALGORITHM'  // Our original analysis
  | 'COMMUNITY_TESTED'    // Community consensus from multiple sources
  | 'CALCULATED';         // Derived from other verified values

export interface SourceRef {
  type: DataSource;
  date: string;           // ISO 8601: "2025-12-03"
  url?: string;
  verified_by?: string;   // Username or reference
  notes?: string;
}

/**
 * Wraps any numeric or structured value with metadata.
 * This enables filtering by confidence and tracking data provenance.
 * 
 * @example
 * const bounty_cash: VersionedValue<number> = {
 *   value: 30,
 *   confidence: 'HIGH',
 *   sources: [{ type: 'GAME_TEST', date: '2025-11-20', verified_by: 'TestPlayer' }],
 *   last_verified: '2025-11-20',
 *   patch_version: '1.40'
 * }
 */
export interface VersionedValue<T> {
  value: T;
  confidence: Confidence;
  sources: SourceRef[];
  last_verified: string;          // ISO 8601
  patch_version?: string;         // Last RDO patch this was verified on
  deprecation_warning?: string;   // If this value is no longer accurate
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ECONOMIC FORMULAS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export type EconomicSystem = 
  | 'bounty_hunter'
  | 'trader'
  | 'moonshiner'
  | 'collector'
  | 'naturalist'
  | 'fast_travel'
  | 'catalog';

export interface FormulaVariable {
  name: string;
  type: 'number' | 'string' | 'boolean';
  description: string;
  allowed_values?: (string | number)[];
  examples?: (string | number)[];
}

export interface FormulaExample {
  description: string;
  input: Record<string, any>;
  expected_output: number | Record<string, any>;
  calculation_steps?: string[];
}

export interface EconomicFormula {
  id: string;                           // e.g., "bounty_payout_cash"
  system: EconomicSystem;
  name: string;                         // "Bounty Payout (Cash)"
  formula: string;                      // Symbolic: "P = B Ã— M_tier Ã— M_status Ã— M_time"
  description?: string;
  variables: FormulaVariable[];
  optimal_parameters?: Record<string, any>;
  examples: FormulaExample[];
  confidence: Confidence;
  sources: SourceRef[];
  patch_version: string;
  last_verified: string;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CATALOG ITEMS (Weapons, Horses, Ability Cards, etc.)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export type ItemCategory = 
  | 'weapon'
  | 'horse'
  | 'ability_card'
  | 'role_item'
  | 'consumable'
  | 'clothing'
  | 'saddle'
  | 'trinket';

export type ItemShop = 
  | 'gunsmith'
  | 'stable'
  | 'fence'
  | 'general_store'
  | 'tailor'
  | 'madam_nazar'
  | 'role_vendor'
  | 'catalog';

export interface ItemPrice {
  cash?: VersionedValue<number>;
  gold?: VersionedValue<number>;
  rank_required?: VersionedValue<number>;
  role_rank_required?: { role: string; rank: VersionedValue<number> };
}

export interface RDOItem {
  id: string;                           // e.g., "w_mauser_pistol"
  name: string;
  category: ItemCategory;
  shop: ItemShop;
  
  // Pricing
  price: ItemPrice;
  
  // Metadata
  rarity?: 'common' | 'uncommon' | 'rare' | 'legendary';
  description?: string;
  type?: string;                        // "Sidearm", "Rifle", "Ability Card", etc.
  
  // Weapon/Horse specific
  stats?: Record<string, number>;       // e.g., { accuracy: 7, damage: 8, reload: 7 }
  
  // Confidence & sources
  confidence: Confidence;
  sources: SourceRef[];
  last_verified: string;
  patch_version: string;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ANIMALS (Hunting/Naturalist)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export interface Material {
  name: string;
  cash_value: VersionedValue<number>;
  yield_probability: VersionedValue<number>;    // 0.0-1.0
  perfect_quality_bonus?: VersionedValue<number>;
  hunting_method?: 'rifle' | 'shotgun' | 'sniper' | 'revolver' | 'headshot';
  knife_loot?: boolean;
}

export interface SpawnLocation {
  region: string;
  latitude: VersionedValue<number>;
  longitude: VersionedValue<number>;
  time_of_day?: ('dawn' | 'day' | 'dusk' | 'night')[];
  weather?: string[];
  frequency: 'rare' | 'uncommon' | 'common';
}

export interface Animal {
  id: string;                           // e.g., "animal_cougar"
  name: string;
  species: string;                      // "Felidae", "Cervidae", etc.
  size: 'small' | 'medium' | 'large';
  
  // Combat
  ai_rating: VersionedValue<number>;    // 1-10 difficulty
  health: VersionedValue<number>;
  stamina?: VersionedValue<number>;
  
  // Loot
  materials: Material[];
  average_profit_per_kill: VersionedValue<number>;
  average_hunt_time_minutes: VersionedValue<number>;
  
  // Location
  spawns: SpawnLocation[];
  
  // Naturalist
  can_study: boolean;
  study_sample_value?: VersionedValue<number>;
  sedative_ammo_type?: 'rifle' | 'revolver' | 'repeater';
  
  // Metadata
  confidence: Confidence;
  sources: SourceRef[];
  last_verified: string;
  patch_version: string;
}

export interface LegendaryAnimal extends Animal {
  is_legendary: true;
  pelt_value: VersionedValue<number>;
  pelt_yields: { poor: number; good: number; perfect: number };
  unique_location: SpawnLocation;
  respawn_time_hours?: VersionedValue<number>;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FAST TRAVEL NETWORK
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export interface FastTravelNode {
  id: string;                           // e.g., "fast_travel_valentine"
  name: string;
  latitude: VersionedValue<number>;
  longitude: VersionedValue<number>;
  region: string;
  cost_cash: VersionedValue<number>;
  
  // Metadata
  confidence: Confidence;
  sources: SourceRef[];
  last_verified: string;
}

export interface FastTravelRoute {
  id: string;
  from_node_id: string;
  to_node_id: string;
  distance_miles: VersionedValue<number>;
  travel_time_seconds: VersionedValue<number>;
  cost_cash: VersionedValue<number>;
  
  // Asymmetry flag: some routes may cost differently in reverse
  asymmetric?: boolean;
  reverse_cost_cash?: VersionedValue<number>;
  
  // Metadata
  confidence: Confidence;
  sources: SourceRef[];
  last_verified: string;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COLLECTORS & CYCLES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export interface CollectorItem {
  id: string;                           // Unique per cycle
  collection_set: string;               // "tarot_cards", "coins", "flowers", etc.
  cycle: VersionedValue<number>;        // 1-3 for most sets
  name: string;
  description?: string;
  
  // Location
  latitude: VersionedValue<number>;
  longitude: VersionedValue<number>;
  region: string;
  
  // Finder method
  finder_type?: 'digging' | 'searching' | 'talking' | 'looting';
  requires_metal_detector?: boolean;
  
  // Payout
  cash_value: VersionedValue<number>;
  
  // Integration with Jeanropke map
  jeanropke_id?: string;
  
  // Metadata
  confidence: Confidence;
  sources: SourceRef[];
  last_verified: string;
  patch_version: string;
}

export interface CollectorSet {
  id: string;                           // "tarot_cards"
  name: string;
  description?: string;
  item_count: VersionedValue<number>;
  cycle_count: VersionedValue<number>;  // How many "rotations" exist
  bonus_cash_per_set: VersionedValue<number>;
  bonus_xp_per_set?: VersionedValue<number>;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ROLES & PROGRESSION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export type RoleType = 'trader' | 'moonshiner' | 'bounty_hunter' | 'collector' | 'naturalist';

export interface RoleUnlock {
  role: RoleType;
  unlock_cost_gold: VersionedValue<number>;
  player_rank_required: VersionedValue<number>;
  description?: string;
}

export interface RankBenefit {
  rank: VersionedValue<number>;         // 1-20
  name: string;
  description?: string;
  income_multiplier?: VersionedValue<number>;
  unlocks?: string[];
}

export interface Role {
  id: RoleType;
  name: string;
  mentor_npc?: string;                  // "Cripps", "Sadie", etc.
  unlock_cost_gold: VersionedValue<number>;
  player_rank_required: VersionedValue<number>;
  max_rank: VersionedValue<number>;
  rank_benefits: RankBenefit[];
  
  // Economics
  average_income_per_hour?: VersionedValue<number>;
  optimal_session_length_hours?: VersionedValue<number>;
  
  // Metadata
  confidence: Confidence;
  sources: SourceRef[];
  last_verified: string;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GEOGRAPHIC REGIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export interface Region {
  id: string;                           // "west_elizabeth"
  name: string;
  center_latitude: VersionedValue<number>;
  center_longitude: VersionedValue<number>;
  
  // Properties
  is_pvp_safe?: boolean;
  free_roam_event_likelihood?: VersionedValue<number>;
  
  // Common animals
  dominant_animals?: string[];          // Animal IDs
  
  // Metadata
  confidence: Confidence;
  sources: SourceRef[];
  last_verified: string;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EVENTS & BONUSES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export interface EconomicBonus {
  id: string;                           // "double_bounty_week_12"
  name: string;
  description?: string;
  
  // Type of bonus
  activity: EconomicSystem | 'all';
  multiplier: VersionedValue<number>;   // 1.5 = 50% bonus
  
  // Timing
  start_date: string;                   // ISO 8601
  end_date?: string;
  is_active: boolean;
  
  // Metadata
  confidence: Confidence;
  sources: SourceRef[];
  last_verified: string;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ROOT: RDO COMPENDIUM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export interface CompendiumMetadata {
  version: string;                      // "3.0.0"
  last_updated: string;                 // ISO 8601
  game_version: string;                 // RDO patch version: "1.40"
  maintainers?: string[];               // GitHub usernames
}

export interface DataQualitySummary {
  total_entries: number;
  high_confidence_entries: number;
  medium_confidence_entries: number;
  low_confidence_entries: number;
  last_verification_date: string;
  missing_high_priority_fields?: string[];
}

export interface RDOCompendium extends CompendiumMetadata {
  // Core data
  items: Record<string, RDOItem>;       // Indexed by ID
  animals: Record<string, Animal | LegendaryAnimal>;
  roles: Record<RoleType, Role>;
  
  // Economics
  formulas: Record<string, EconomicFormula>;
  bonuses: EconomicBonus[];
  
  // Geography
  regions: Record<string, Region>;
  fast_travel_nodes: Record<string, FastTravelNode>;
  fast_travel_routes: FastTravelRoute[];
  
  // Collectors
  collector_sets: Record<string, CollectorSet>;
  collector_items: Record<string, CollectorItem>;
  
  // Metadata
  data_quality_summary: DataQualitySummary;
}

export default RDOCompendium;

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * COMPENDIUM SLICE - Static Data Management (The Truth)
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * Holds all static game data: Items, Animals, Formulas, Roles, Regions.
 * This is the "Source of Truth" that never changes during a session.
 * Data is loaded once at app startup from JSON files.
 */

import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import type {
  RDOCompendium,
  CatalogItem,
  Animal,
  LegendaryAnimal,
  EconomicFormula,
  FastTravelNode,
  FastTravelRoute,
  Region,
  Role,
  CollectorSet,
  EconomicBonus,
} from '../data/schema/rdo_unified_schema';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INITIAL STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const initialState: {
  data: RDOCompendium | null;
  loading: boolean;
  error: string | null;
  lastLoaded: string | null;
} = {
  data: null,
  loading: false,
  error: null,
  lastLoaded: null,
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SLICE DEFINITION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export const compendiumSlice = createSlice({
  name: 'compendium',
  initialState,
  reducers: {
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // LOAD OPERATIONS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Initiate data load (show loading state)
     */
    setLoading: (state) => {
      state.loading = true;
      state.error = null;
    },

    /**
     * Complete data load with full compendium
     * @example
     * dispatch(loadCompendiumSuccess(compendiumJSON))
     */
    loadCompendiumSuccess: (state, action: PayloadAction<RDOCompendium>) => {
      state.data = action.payload;
      state.loading = false;
      state.error = null;
      state.lastLoaded = new Date().toISOString();
    },

    /**
     * Handle load error
     */
    loadCompendiumError: (state, action: PayloadAction<string>) => {
      state.loading = false;
      state.error = action.payload;
      state.data = null;
    },

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PARTIAL UPDATES (For hot-reloading during development)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Update a single item in catalog
     */
    updateItem: (state, action: PayloadAction<CatalogItem>) => {
      if (!state.data) return;
      state.data.items[action.payload.id] = action.payload;
    },

    /**
     * Update multiple items
     */
    updateItems: (state, action: PayloadAction<CatalogItem[]>) => {
      if (!state.data) return;
      action.payload.forEach((item) => {
        state.data!.items[item.id] = item;
      });
    },

    /**
     * Update an animal
     */
    updateAnimal: (state, action: PayloadAction<Animal | LegendaryAnimal>) => {
      if (!state.data) return;
      state.data.animals[action.payload.id] = action.payload;
    },

    /**
     * Update multiple animals
     */
    updateAnimals: (state, action: PayloadAction<(Animal | LegendaryAnimal)[]>) => {
      if (!state.data) return;
      action.payload.forEach((animal) => {
        state.data!.animals[animal.id] = animal;
      });
    },

    /**
     * Update a formula
     */
    updateFormula: (state, action: PayloadAction<EconomicFormula>) => {
      if (!state.data) return;
      state.data.formulas[action.payload.id] = action.payload;
    },

    /**
     * Update a region
     */
    updateRegion: (state, action: PayloadAction<Region>) => {
      if (!state.data) return;
      state.data.regions[action.payload.id] = action.payload;
    },

    /**
     * Update a role
     */
    updateRole: (state, action: PayloadAction<Role>) => {
      if (!state.data) return;
      state.data.roles[action.payload.id] = action.payload;
    },

    /**
     * Update fast travel network
     */
    updateFastTravelNetwork: (
      state,
      action: PayloadAction<{
        nodes: Record<string, FastTravelNode>;
        routes: FastTravelRoute[];
      }>
    ) => {
      if (!state.data) return;
      state.data.fast_travel_nodes = action.payload.nodes;
      state.data.fast_travel_routes = action.payload.routes;
    },

    /**
     * Update collector sets
     */
    updateCollectorSets: (state, action: PayloadAction<CollectorSet[]>) => {
      if (!state.data) return;
      state.data.collector_sets = action.payload;
    },

    /**
     * Update active economic bonuses
     */
    updateEconomicBonuses: (state, action: PayloadAction<EconomicBonus[]>) => {
      if (!state.data) return;
      state.data.bonuses = action.payload;
    },

    /**
     * Update data quality summary (useful for UI)
     */
    updateDataQualitySummary: (
      state,
      action: PayloadAction<{
        high_confidence_items: number;
        medium_confidence_items: number;
        low_confidence_items: number;
        last_verification_date: string;
      }>
    ) => {
      if (!state.data) return;
      state.data.data_quality_summary = action.payload;
    },

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // BULK OPERATIONS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Clear all data (useful for logout or reset)
     */
    clearCompendium: (state) => {
      state.data = null;
      state.error = null;
      state.lastLoaded = null;
    },

    /**
     * Merge new data with existing data (for incremental updates)
     */
    mergeCompendium: (state, action: PayloadAction<Partial<RDOCompendium>>) => {
      if (!state.data) {
        state.data = {
          version: '3.0',
          last_updated: new Date().toISOString(),
          game_version: 'unknown',
          items: {},
          animals: {},
          formulas: {},
          bonuses: [],
          regions: {},
          fast_travel_nodes: {},
          fast_travel_routes: [],
          roles: {},
          collector_sets: [],
          data_quality_summary: {
            high_confidence_items: 0,
            medium_confidence_items: 0,
            low_confidence_items: 0,
            last_verification_date: new Date().toISOString(),
          },
          ...action.payload,
        };
      } else {
        // Merge dictionaries
        if (action.payload.items) {
          state.data.items = { ...state.data.items, ...action.payload.items };
        }
        if (action.payload.animals) {
          state.data.animals = { ...state.data.animals, ...action.payload.animals };
        }
        if (action.payload.formulas) {
          state.data.formulas = { ...state.data.formulas, ...action.payload.formulas };
        }
        if (action.payload.regions) {
          state.data.regions = { ...state.data.regions, ...action.payload.regions };
        }
        if (action.payload.roles) {
          state.data.roles = { ...state.data.roles, ...action.payload.roles };
        }
        if (action.payload.fast_travel_nodes) {
          state.data.fast_travel_nodes = {
            ...state.data.fast_travel_nodes,
            ...action.payload.fast_travel_nodes,
          };
        }
        // Replace arrays
        if (action.payload.fast_travel_routes) {
          state.data.fast_travel_routes = action.payload.fast_travel_routes;
        }
        if (action.payload.bonuses) {
          state.data.bonuses = action.payload.bonuses;
        }
        if (action.payload.collector_sets) {
          state.data.collector_sets = action.payload.collector_sets;
        }
        // Update metadata
        if (action.payload.last_updated) {
          state.data.last_updated = action.payload.last_updated;
        }
      }
    },
  },
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPER SELECTORS (Can also be in a separate selectors.ts file)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Quick selector to check if data is loaded
 * Usage: useAppSelector(selectCompendiumLoaded)
 */
export const selectCompendiumLoaded = (state: any) => {
  return state.compendium.data !== null && !state.compendium.loading;
};

/**
 * Quick selector to get all items
 */
export const selectAllItems = (state: any) => {
  return state.compendium.data?.items || {};
};

/**
 * Quick selector to get all animals
 */
export const selectAllAnimals = (state: any) => {
  return state.compendium.data?.animals || {};
};

/**
 * Quick selector to get all formulas
 */
export const selectAllFormulas = (state: any) => {
  return state.compendium.data?.formulas || {};
};

/**
 * Quick selector to get all roles
 */
export const selectAllRoles = (state: any) => {
  return state.compendium.data?.roles || {};
};

/**
 * Quick selector to get fast travel nodes
 */
export const selectFastTravelNodes = (state: any) => {
  return state.compendium.data?.fast_travel_nodes || {};
};

/**
 * Quick selector to get collector sets
 */
export const selectCollectorSets = (state: any) => {
  return state.compendium.data?.collector_sets || [];
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXPORTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export const compendiumActions = compendiumSlice.actions;
export default compendiumSlice.reducer;

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ECONOMICS SLICE - Calculated Economic Data Cache
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * Caches calculated values: Profit Projections, Optimal Routes, etc.
 * This is expensive calculations that we want to memoize across renders.
 */

import { createSlice, PayloadAction } from '@reduxjs/toolkit';

export interface CalculatedProfit {
  activity: string;          // bounty, trader, moonshiner, collector, naturalist
  base_profit: number;
  bonuses_applied: number;
  total_profit: number;
  time_required: number;     // Seconds
  profit_per_hour: number;
  metadata?: Record<string, any>;
}

export interface OptimalRoute {
  activity: string;
  steps: Array<{
    description: string;
    duration: number;
    reward: number;
  }>;
  total_duration: number;
  total_reward: number;
  efficiency: number;        // Reward per hour
}

interface EconomicsState {
  calculated_profits: Record<string, CalculatedProfit>;
  optimal_routes: Record<string, OptimalRoute>;
  role_rankings: Array<{
    role: string;
    profit_per_hour: number;
    recent_average: number;
  }>;
  last_calculated: string | null;
}

const initialState: EconomicsState = {
  calculated_profits: {},
  optimal_routes: {},
  role_rankings: [],
  last_calculated: null,
};

export const economicsSlice = createSlice({
  name: 'economics',
  initialState,
  reducers: {
    /**
     * Update calculated profit for an activity
     */
    updateProfit: (
      state,
      action: PayloadAction<{ key: string; profit: CalculatedProfit }>
    ) => {
      state.calculated_profits[action.payload.key] = action.payload.profit;
      state.last_calculated = new Date().toISOString();
    },

    /**
     * Update multiple profits at once
     */
    updateProfits: (state, action: PayloadAction<Record<string, CalculatedProfit>>) => {
      state.calculated_profits = { ...state.calculated_profits, ...action.payload };
      state.last_calculated = new Date().toISOString();
    },

    /**
     * Update optimal route calculation
     */
    updateRoute: (
      state,
      action: PayloadAction<{ key: string; route: OptimalRoute }>
    ) => {
      state.optimal_routes[action.payload.key] = action.payload.route;
      state.last_calculated = new Date().toISOString();
    },

    /**
     * Update all routes
     */
    updateRoutes: (state, action: PayloadAction<Record<string, OptimalRoute>>) => {
      state.optimal_routes = { ...state.optimal_routes, ...action.payload };
      state.last_calculated = new Date().toISOString();
    },

    /**
     * Update role rankings (sorted by efficiency)
     */
    updateRoleRankings: (
      state,
      action: PayloadAction<
        Array<{
          role: string;
          profit_per_hour: number;
          recent_average: number;
        }>
      >
    ) => {
      state.role_rankings = action.payload;
      state.last_calculated = new Date().toISOString();
    },

    /**
     * Clear all calculations (useful for recalculation)
     */
    clearCalculations: (state) => {
      state.calculated_profits = {};
      state.optimal_routes = {};
      state.role_rankings = [];
    },
  },
});

export const economicsActions = economicsSlice.actions;
export default economicsSlice.reducer;

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ENVIRONMENT SLICE - Game World State
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * Tracks environment conditions: Time of Day, Weather, Active Bonuses, Events
 */

import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import type { EconomicBonus } from '../data/schema/rdo_unified_schema';

export type TimeOfDay = 'dawn' | 'day' | 'dusk' | 'night';
export type WeatherType = 'clear' | 'cloudy' | 'rainy' | 'stormy' | 'snowy' | 'foggy';

interface EnvironmentState {
  time_of_day: TimeOfDay;
  weather: WeatherType;
  active_bonuses: EconomicBonus[];
  current_date: string;
  game_speed_multiplier: number;  // 1.0 = normal, 0.5 = double speed
  server_maintenance: boolean;
}

const initialState: EnvironmentState = {
  time_of_day: 'day',
  weather: 'clear',
  active_bonuses: [],
  current_date: new Date().toISOString().split('T')[0],
  game_speed_multiplier: 1.0,
  server_maintenance: false,
};

export const environmentSlice = createSlice({
  name: 'environment',
  initialState,
  reducers: {
    /**
     * Update time of day
     */
    setTimeOfDay: (state, action: PayloadAction<TimeOfDay>) => {
      state.time_of_day = action.payload;
    },

    /**
     * Update weather
     */
    setWeather: (state, action: PayloadAction<WeatherType>) => {
      state.weather = action.payload;
    },

    /**
     * Set active economic bonuses
     */
    setActiveBonuses: (state, action: PayloadAction<EconomicBonus[]>) => {
      state.active_bonuses = action.payload;
    },

    /**
     * Add a bonus
     */
    addBonus: (state, action: PayloadAction<EconomicBonus>) => {
      state.active_bonuses.push(action.payload);
    },

    /**
     * Remove a bonus by ID
     */
    removeBonus: (state, action: PayloadAction<string>) => {
      state.active_bonuses = state.active_bonuses.filter(
        (b) => b.id !== action.payload
      );
    },

    /**
     * Update current date
     */
    setCurrentDate: (state, action: PayloadAction<string>) => {
      state.current_date = action.payload;
    },

    /**
     * Set game speed multiplier (for simulation)
     */
    setGameSpeedMultiplier: (state, action: PayloadAction<number>) => {
      state.game_speed_multiplier = Math.max(0.1, action.payload);
    },

    /**
     * Set server maintenance flag
     */
    setServerMaintenance: (state, action: PayloadAction<boolean>) => {
      state.server_maintenance = action.payload;
    },
  },
});

export const environmentActions = environmentSlice.actions;
export default environmentSlice.reducer;

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * SIMULATION SLICE - Player State Management
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * Handles all player character state: Cash, Gold, Rank, Role Ranks, etc.
 * This is the STATE part of "State > Logic > Data"
 */

import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import type { PlayerCharacter, SimulationAdjustments } from '../data/schema/rdo_unified_schema';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INITIAL STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const initialState: PlayerCharacter = {
  character_id: 'demo_character',
  rank: 25,
  cash: 5000.00,
  gold_bars: 50.00,
  honor_level: 0,
  health_level: 5,
  stamina_level: 5,
  dead_eye_level: 5,
  
  // Role Ranks
  trader_rank: 10,
  moonshiner_rank: 15,
  bounty_hunter_rank: 12,
  collector_rank: 0,
  naturalist_rank: 0,
  
  // Role States
  trader_goods: 75,
  trader_wagon_size: 'large',
  moonshiner_shack_level: 3,
  moonshiner_current_batch: null,
  moonshiner_batch_progress: 0,
  
  // Session
  in_posse: false,
  roles_owned: ['trader', 'moonshiner', 'bounty_hunter'],
  current_location: 'emerald_station',
  camp_location: 'heartlands_camp',
  last_update: Date.now(),
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SLICE DEFINITION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export const simulationSlice = createSlice({
  name: 'simulation',
  initialState,
  reducers: {
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CASH MANAGEMENT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Update cash (add or subtract, clamped to 0+)
     * @param amount - Positive to add, negative to subtract
     * 
     * @example
     * dispatch(updatePlayerCash(500))    // Add $500
     * dispatch(updatePlayerCash(-100))   // Subtract $100
     */
    updatePlayerCash: (state, action: PayloadAction<number>) => {
      state.cash = Math.max(0, state.cash + action.payload);
      state.last_update = Date.now();
    },

    /**
     * Set cash to exact amount
     * @example
     * dispatch(setPlayerCash(1000)) // Set to exactly $1,000
     */
    setPlayerCash: (state, action: PayloadAction<number>) => {
      state.cash = Math.max(0, action.payload);
      state.last_update = Date.now();
    },

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // GOLD MANAGEMENT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Update gold bars (add or subtract, clamped to 0+)
     * @example
     * dispatch(updatePlayerGold(5))     // Add 5 gold bars
     * dispatch(updatePlayerGold(-2))    // Subtract 2 gold bars
     */
    updatePlayerGold: (state, action: PayloadAction<number>) => {
      state.gold_bars = Math.max(0, state.gold_bars + action.payload);
      state.last_update = Date.now();
    },

    /**
     * Set gold to exact amount
     * @example
     * dispatch(setPlayerGold(25)) // Set to exactly 25 gold bars
     */
    setPlayerGold: (state, action: PayloadAction<number>) => {
      state.gold_bars = Math.max(0, action.payload);
      state.last_update = Date.now();
    },

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // RANK MANAGEMENT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Update player rank (clamped to 1-500)
     * @example
     * dispatch(updatePlayerRank(5)) // Gain 5 ranks
     */
    updatePlayerRank: (state, action: PayloadAction<number>) => {
      state.rank = Math.min(500, Math.max(1, state.rank + action.payload));
      state.last_update = Date.now();
    },

    /**
     * Set rank to exact level
     */
    setPlayerRank: (state, action: PayloadAction<number>) => {
      state.rank = Math.min(500, Math.max(1, action.payload));
      state.last_update = Date.now();
    },

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ROLE RANK MANAGEMENT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Update a specific role rank (clamped to 0-20)
     * @example
     * dispatch(updateRoleRank({ role: 'trader', rank: 15 }))
     */
    updateRoleRank: (
      state,
      action: PayloadAction<{ role: string; rank: number }>
    ) => {
      const { role, rank } = action.payload;
      const key = `${role}_rank` as keyof PlayerCharacter;
      (state[key] as number) = Math.min(20, Math.max(0, rank));
      state.last_update = Date.now();
    },

    /**
     * Add to a role rank
     * @example
     * dispatch(incrementRoleRank({ role: 'bounty_hunter', amount: 2 }))
     */
    incrementRoleRank: (
      state,
      action: PayloadAction<{ role: string; amount: number }>
    ) => {
      const { role, amount } = action.payload;
      const key = `${role}_rank` as keyof PlayerCharacter;
      const current = (state[key] as number) || 0;
      (state[key] as number) = Math.min(20, Math.max(0, current + amount));
      state.last_update = Date.now();
    },

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TRADER STATE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Update trader goods fill level (0-100)
     * @example
     * dispatch(updateTraderGoods(50)) // Set to 50% full
     */
    updateTraderGoods: (state, action: PayloadAction<number>) => {
      state.trader_goods = Math.max(0, Math.min(100, action.payload));
      state.last_update = Date.now();
    },

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MOONSHINER STATE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Update moonshiner batch production
     * @example
     * dispatch(updateMoonshinerBatch({ 
     *   quality: 'strong', 
     *   progress: 50 
     * }))
     */
    updateMoonshinerBatch: (
      state,
      action: PayloadAction<{
        quality: 'weak' | 'average' | 'strong' | null;
        progress: number;
      }>
    ) => {
      const { quality, progress } = action.payload;
      state.moonshiner_current_batch = quality;
      state.moonshiner_batch_progress = Math.max(0, Math.min(100, progress));
      state.last_update = Date.now();
    },

    /**
     * Set moonshiner shack level (1-3)
     */
    setMoonshinerShackLevel: (state, action: PayloadAction<number>) => {
      state.moonshiner_shack_level = Math.min(3, Math.max(1, action.payload));
      state.last_update = Date.now();
    },

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // COMPOUND UPDATES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Bulk update player state
     * @example
     * dispatch(setPlayerState({ 
     *   cash: 2000, 
     *   gold_bars: 100,
     *   rank: 50
     * }))
     */
    setPlayerState: (state, action: PayloadAction<Partial<PlayerCharacter>>) => {
      return { ...state, ...action.payload, last_update: Date.now() };
    },

    /**
     * Reset to initial state (useful for starting new simulation)
     */
    resetSimulation: () => initialState,

    /**
     * Restore saved state from localStorage/export
     */
    restoreSimulation: (state, action: PayloadAction<PlayerCharacter>) => {
      return action.payload;
    },

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // HONOR & ABILITY LEVELS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Update honor level (-8 to +8)
     */
    updateHonor: (state, action: PayloadAction<number>) => {
      state.honor_level = Math.min(8, Math.max(-8, state.honor_level + action.payload));
      state.last_update = Date.now();
    },

    /**
     * Update health/stamina/dead eye level (1-5)
     */
    updateAbilityLevel: (
      state,
      action: PayloadAction<{ ability: 'health' | 'stamina' | 'dead_eye'; level: number }>
    ) => {
      const { ability, level } = action.payload;
      const key = `${ability}_level` as keyof PlayerCharacter;
      (state[key] as number) = Math.min(5, Math.max(1, level));
      state.last_update = Date.now();
    },

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // LOCATION & POSSE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Update current location
     * @example
     * dispatch(setCurrentLocation('valentine'))
     */
    setCurrentLocation: (state, action: PayloadAction<string>) => {
      state.current_location = action.payload;
      state.last_update = Date.now();
    },

    /**
     * Toggle posse status
     */
    togglePosse: (state, action: PayloadAction<boolean>) => {
      state.in_posse = action.payload;
      state.last_update = Date.now();
    },

    /**
     * Update roles owned
     */
    setRolesOwned: (state, action: PayloadAction<string[]>) => {
      state.roles_owned = action.payload;
      state.last_update = Date.now();
    },
  },
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXPORTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export const simulationActions = simulationSlice.actions;
export default simulationSlice.reducer;

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * SAFE CALCULATOR HOOK - Graceful Error Handling
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * Wraps simulator function calls in try/catch to prevent component crashes.
 * If validation fails, the error is displayed locally instead of crashing.
 */

import { useState, useCallback } from 'react';

export interface CalculationState<T> {
  result: T | null;
  error: string | null;
  isCalculating: boolean;
}

/**
 * Hook for safe calculator calls with local error handling
 * 
 * @example
 * const { result, error, calculate } = useCalculator(calculateBountyPayout);
 * 
 * const handleCalculate = () => {
 *   calculate({ tier: 2, alive: true, targetCount: 1, minutesElapsed: 12 });
 * };
 * 
 * if (error) return <div className="text-red-400">{error}</div>;
 * if (result) return <div>{result.cash}</div>;
 */
export function useCalculator<T extends any[], R>(
  calculatorFn: (...args: T) => R
): CalculationState<R> & { calculate: (...args: T) => void } {
  const [state, setState] = useState<CalculationState<R>>({
    result: null,
    error: null,
    isCalculating: false,
  });

  const calculate = useCallback(
    (...args: T) => {
      setState({ result: null, error: null, isCalculating: true });

      try {
        // === CRITICAL FIX: Catch validation errors locally ===
        const result = calculatorFn(...args);
        setState({
          result,
          error: null,
          isCalculating: false,
        });
      } catch (err) {
        // Don't crash the component - show error message instead
        const errorMessage = err instanceof Error ? err.message : 'Unknown calculation error';
        
        console.warn('âš ï¸ Calculator validation error:', errorMessage);
        
        setState({
          result: null,
          error: errorMessage,
          isCalculating: false,
        });
      }
    },
    [calculatorFn]
  );

  return {
    ...state,
    calculate,
  };
}

/**
 * Hook for safe async calculator calls (future use)
 * Similar to useCalculator but handles async calculators
 */
export function useAsyncCalculator<T extends any[], R>(
  calculatorFn: (...args: T) => Promise<R>
): CalculationState<R> & { calculate: (...args: T) => Promise<void> } {
  const [state, setState] = useState<CalculationState<R>>({
    result: null,
    error: null,
    isCalculating: false,
  });

  const calculate = useCallback(
    async (...args: T) => {
      setState({ result: null, error: null, isCalculating: true });

      try {
        const result = await calculatorFn(...args);
        setState({
          result,
          error: null,
          isCalculating: false,
        });
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Unknown calculation error';
        console.warn('âš ï¸ Async calculator error:', errorMessage);
        setState({
          result: null,
          error: errorMessage,
          isCalculating: false,
        });
      }
    },
    [calculatorFn]
  );

  return {
    ...state,
    calculate,
  };
}

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * SYSTEM LOADER HOOK - Bootstrap the Entire Application
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * This is the "Adapter" that bridges static JSON files into Redux State.
 * It runs once on app startup and initializes all systems.
 * 
 * To add a new system (e.g., Naturalist):
 * 1. Create naturalist-data.json in data/static/
 * 2. Import it here
 * 3. Dispatch action to load it into compendium slice
 * 4. Wrap your App component with <Suspense fallback={<Loading />}>
 */

import { useEffect, useState, useCallback } from 'react';
import { useAppDispatch, useAppSelector } from '../app/hooks';
import { compendiumActions } from '../features/compendiumSlice';
import { environmentActions } from '../features/environmentSlice';
import { loadStateFromStorage, saveStateToStorage } from '../app/store';
import { simulationActions } from '../features/simulationSlice';
import type { RDOCompendium } from '../data/schema/rdo_unified_schema';
import { FALLBACK_ITEMS } from '../domain/fallbackData';

// Import static data files
import compendiumData from '../data/static/compendium.json';

export interface SystemLoaderStatus {
  isReady: boolean;
  isLoading: boolean;
  error: string | null;
  progress: {
    compendium: boolean;
    environment: boolean;
    simulation: boolean;
    storage: boolean;
  };
}

/**
 * Hook that initializes the entire RDO OS on app startup
 * 
 * @returns {SystemLoaderStatus} Current loading status
 * 
 * @example
 * function App() {
 *   const { isReady, isLoading, error } = useSystemLoader();
 *   
 *   if (isLoading) return <LoadingScreen />;
 *   if (error) return <ErrorScreen error={error} />;
 *   if (!isReady) return <BootScreen />;
 *   
 *   return <MainApp />;
 * }
 */
export const useSystemLoader = (): SystemLoaderStatus => {
  const dispatch = useAppDispatch();
  const compendiumLoaded = useAppSelector((state) => state.compendium.data !== null);

  const [status, setStatus] = useState<SystemLoaderStatus>({
    isReady: false,
    isLoading: true,
    error: null,
    progress: {
      compendium: false,
      environment: false,
      simulation: false,
      storage: false,
    },
  });

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // LOAD COMPENDIUM
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const loadCompendium = useCallback(async () => {
    try {
      console.log('ðŸ”„ RDO OS: Loading Compendium...');
      dispatch(compendiumActions.setLoading());

      // Load the compendium JSON
      const loadedCompendium = compendiumData as RDOCompendium;

      dispatch(compendiumActions.loadCompendiumSuccess(loadedCompendium));
      console.log('âœ… Compendium loaded');

      setStatus((s) => ({
        ...s,
        progress: { ...s.progress, compendium: true },
      }));
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : 'Unknown error';
      console.error('âŒ Failed to load compendium:', errorMsg);
      console.warn('âš ï¸ CRITICAL: Using fallback data to prevent app crash');
      
      // === CRITICAL FIX: Load fallback data instead of crashing ===
      const fallbackCompendium: RDOCompendium = {
        items: FALLBACK_ITEMS,
        animals: [],
        legendary_animals: [],
        formulas: [],
        fast_travel_routes: [],
        regions: [],
        roles: [],
        collector_sets: [],
      };
      
      dispatch(compendiumActions.loadCompendiumSuccess(fallbackCompendium));
      
      setStatus((s) => ({
        ...s,
        error: `Using fallback data: ${errorMsg}`,
        progress: { ...s.progress, compendium: true }, // Mark as complete despite error
      }));
    }
  }, [dispatch]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // LOAD ENVIRONMENT
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const loadEnvironment = useCallback(() => {
    try {
      console.log('ðŸ”„ RDO OS: Loading Environment...');

      // Set current date
      dispatch(
        environmentActions.setCurrentDate(
          new Date().toISOString().split('T')[0]
        )
      );

      // TODO: Fetch bonuses from external source (API, JSON, etc.)
      // For now, initialize with empty bonuses
      dispatch(environmentActions.setActiveBonuses([]));

      console.log('âœ… Environment loaded');

      setStatus((s) => ({
        ...s,
        progress: { ...s.progress, environment: true },
      }));
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : 'Unknown error';
      console.error('âŒ Failed to load environment:', errorMsg);
      setStatus((s) => ({
        ...s,
        error: errorMsg,
      }));
    }
  }, [dispatch]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // LOAD SIMULATION STATE (From localStorage)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const loadSimulation = useCallback(() => {
    try {
      console.log('ðŸ”„ RDO OS: Loading Simulation State...');

      const savedState = loadStateFromStorage('simulation');

      if (savedState) {
        console.log('ðŸ“‚ Restoring saved simulation state');
        dispatch(simulationActions.restoreSimulation(savedState));
      } else {
        console.log('ðŸ†• Starting new simulation (no saved state)');
      }

      setStatus((s) => ({
        ...s,
        progress: { ...s.progress, simulation: true },
      }));
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : 'Unknown error';
      console.error('âŒ Failed to load simulation:', errorMsg);
      // Don't fail on simulation load error - start fresh
      setStatus((s) => ({
        ...s,
        progress: { ...s.progress, simulation: true },
      }));
    }
  }, [dispatch]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // BOOT SEQUENCE
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  useEffect(() => {
    const bootSystem = async () => {
      console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
      console.log('ðŸŽ® RDO CHARACTER OS v3.0 - BOOT SEQUENCE');
      console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

      try {
        // 1. Load the Compendium (all static data)
        await loadCompendium();

        // 2. Load Environment (bonuses, time, weather)
        loadEnvironment();

        // 3. Load Simulation (player state from storage)
        loadSimulation();

        // 4. All systems online
        console.log('âœ… RDO OS: Systems Online');
        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

        setStatus((s) => ({
          ...s,
          isReady: true,
          isLoading: false,
          error: null,
        }));
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : 'Unknown error';
        console.error('âŒ RDO OS: Boot sequence failed', errorMsg);
        setStatus((s) => ({
          ...s,
          isLoading: false,
          error: errorMsg,
        }));
      }
    };

    bootSystem();
  }, [loadCompendium, loadEnvironment, loadSimulation]);

  return status;
};

/**
 * Hook to save current state to localStorage
 * Call this whenever user makes changes they want to persist
 * 
 * @example
 * const saveState = useSaveState();
 * 
 * useEffect(() => {
 *   saveState();
 * }, [sim, saveState]);
 */
export const useSaveState = () => {
  const dispatch = useAppDispatch();
  const sim = useAppSelector((state) => state.simulation);
  const env = useAppSelector((state) => state.environment);
  const econ = useAppSelector((state) => state.economics);

  return useCallback(() => {
    saveStateToStorage('simulation', sim);
    saveStateToStorage('environment', env);
    saveStateToStorage('economics', econ);
    console.log('ðŸ’¾ State saved to localStorage');
  }, [sim, env, econ]);
};

import { describe, it, expect } from 'vitest';
import { migrateV2ToV3 } from '../v2_to_v3_migrator';

describe('V2 to V3 Migration', () => {
  it('migrates items with full validation', () => {
    const v2Data = {
      items: [
        {
          id: 'metal_detector',
          name: 'Metal Detector',
          category: 'tool',
          shop: 'fence',
          price: 700,
          gold_price: 0,
          type: 'TOOL',
          sources: [
            {
              type: 'GAME_TEST' as const,
              date: '2024-12-01',
              verified_by: 'chad_lance',
            },
          ],
          patch_version: '1.29',
          last_verified: '2024-12-01',
        },
      ],
    };

    const result = migrateV2ToV3(v2Data);

    expect(result.report.success).toBe(true);
    expect(Object.keys(result.items)).toHaveLength(1);
    expect(result.items['metal_detector'].price.cash?.confidence).toBe('MEDIUM');
  });

  it('detects missing required fields', () => {
    const v2Data = {
      items: [{ name: 'Broken Item' }], // missing id
    };

    const result = migrateV2ToV3(v2Data);

    expect(result.report.success).toBe(false);
    expect(result.report.errors.length).toBeGreaterThan(0);
  });

  it('infers HIGH confidence from game tests + multiple other sources', () => {
    const v2Data = {
      items: [
        {
          id: 'carcano',
          name: 'Carcano Rifle',
          category: 'weapon',
          shop: 'gunsmith',
          price: 456,
          sources: [
            { type: 'GAME_TEST' as const, date: '2024-12-01' },
            {
              type: 'REDDIT' as const,
              date: '2024-11-28',
              url: 'https://reddit.com/r/RedDeadOnline/',
            },
            {
              type: 'WIKI' as const,
              date: '2024-12-02',
              url: 'https://reddead.fandom.com/',
            },
          ],
        },
      ],
    };

    const result = migrateV2ToV3(v2Data);

    expect(result.items['carcano'].price.cash?.confidence).toBe('HIGH');
  });

  it('handles missing sources gracefully', () => {
    const v2Data = {
      items: [
        {
          id: 'generic_item',
          name: 'Generic Item',
          category: 'weapon',
          shop: 'general_store',
          price: 100,
          // no sources
        },
      ],
    };

    const result = migrateV2ToV3(v2Data);

    expect(result.report.success).toBe(true);
    expect(result.items['generic_item'].price.cash?.confidence).toBe('LOW');
    expect(result.report.gaps.length).toBeGreaterThan(0);
  });

  it('validates source dates in ISO format', () => {
    const v2Data = {
      items: [
        {
          id: 'dated_item',
          name: 'Dated Item',
          category: 'weapon',
          shop: 'gunsmith',
          price: 200,
          sources: [
            {
              type: 'GAME_TEST' as const,
              date: '2024-12-01', // valid
            },
          ],
        },
      ],
    };

    const result = migrateV2ToV3(v2Data);

    expect(result.report.success).toBe(true);
    expect(result.items['dated_item'].sources[0].date).toBe('2024-12-01');
  });

  it('migrates formulas with system and variables', () => {
    const v2Data = {
      economic_formulas: [
        {
          id: 'bounty_payout',
          system: 'bounty_hunter',
          name: 'Bounty Payout Formula',
          formula: 'P = B Ã— M_tier Ã— M_status Ã— M_rank',
          variables: ['base_payout', 'tier_multiplier', 'status_multiplier', 'rank_multiplier'],
          sources: [
            {
              type: 'GAME_TEST' as const,
              date: '2024-12-01',
              verified_by: 'testing_team',
            },
          ],
          patch_version: '1.29',
        },
      ],
    };

    const result = migrateV2ToV3(v2Data);

    expect(result.report.success).toBe(true);
    expect(Object.keys(result.formulas)).toHaveLength(1);
    expect(result.formulas['bounty_payout'].system).toBe('bounty_hunter');
    expect(result.formulas['bounty_payout'].variables).toHaveLength(4);
  });

  it('migrates animals with materials and spawn info', () => {
    const v2Data = {
      animals: [
        {
          id: 'buck_whitetail',
          name: 'White Tail Buck',
          species: 'Deer',
          size: 'large',
          ai_rating: 7,
          health: 100,
          materials: ['fur', 'antlers'],
          spawns: ['Big Valley', 'West Elizabeth'],
          can_study: true,
          sources: [
            {
              type: 'GAME_TEST' as const,
              date: '2024-12-01',
            },
          ],
        },
      ],
    };

    const result = migrateV2ToV3(v2Data);

    expect(result.report.success).toBe(true);
    expect(result.animals['buck_whitetail'].name).toBe('White Tail Buck');
    expect(result.animals['buck_whitetail'].materials).toContain('fur');
  });

  it('reports confidence statistics', () => {
    const v2Data = {
      items: [
        {
          id: 'high_item',
          name: 'High Confidence',
          category: 'weapon',
          shop: 'gunsmith',
          price: 100,
          sources: [
            { type: 'GAME_TEST' as const, date: '2024-12-01' },
            { type: 'REDDIT' as const, date: '2024-12-02', url: 'https://reddit.com/' },
            { type: 'WIKI' as const, date: '2024-12-03', url: 'https://wiki.com/' },
          ],
        },
        {
          id: 'low_item',
          name: 'Low Confidence',
          category: 'weapon',
          shop: 'gunsmith',
          price: 200,
          sources: [
            { type: 'YOUTUBE' as const, date: '2024-06-01', url: 'https://youtube.com/' },
          ],
        },
      ],
    };

    const result = migrateV2ToV3(v2Data);

    expect(result.report.stats.high_confidence_items).toBe(1);
    expect(result.report.stats.low_confidence_items).toBe(1);
    expect(result.report.summary).toContain('HIGH');
  });

  it('generates meaningful migration report', () => {
    const v2Data = {
      items: [
        {
          id: 'test_item',
          name: 'Test Item',
          category: 'weapon',
          shop: 'gunsmith',
          price: 150,
          sources: [{ type: 'GAME_TEST' as const, date: '2024-12-01' }],
        },
      ],
    };

    const result = migrateV2ToV3(v2Data);

    expect(result.report.timestamp).toBeTruthy();
    expect(result.report.summary).toContain('MIGRATION COMPLETE');
    expect(result.report.stats.items_migrated).toBe(1);
  });
});

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * V2 TO V3 MIGRATION ENGINE
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * Converts legacy extraction log format into Redux-ready normalized data.
 * 
 * Key Features:
 * - Validation with detailed error reporting
 * - Confidence level inference from source quality
 * - Duplicate detection and resolution
 * - Missing data gap analysis
 */

import type {
  RDOItem,
  EconomicFormula,
  Animal,
  FastTravelNode,
  FastTravelRoute,
  CollectorItem,
  Role,
  SourceRef,
  Confidence,
  ItemCategory,
  ItemShop,
} from '../domain/rdo_unified_schema';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VALIDATION HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Infer confidence level based on source quality and recency
 * HIGH: Game test + 2+ other sources (any type) = comprehensive verification
 * MEDIUM: Game test alone OR (2+ sources with at least one game test) = good data
 * LOW: Single source OR no game test = needs review
 */
function inferConfidence(sources: SourceRef[]): Confidence {
  if (!sources || sources.length === 0) return 'LOW';

  const hasGameTest = sources.some((s) => s.type === 'GAME_TEST');
  const otherSources = sources.filter((s) => s.type !== 'GAME_TEST').length;

  // HIGH: Game test + 2+ other independent sources = comprehensive
  if (hasGameTest && otherSources >= 2) return 'HIGH';

  // MEDIUM: Game test alone, or multiple sources with game test
  if (hasGameTest || sources.length >= 3) return 'MEDIUM';

  // LOW: Single source or no validation
  return 'LOW';
}

function validateSourceRef(source: any): source is SourceRef {
  return (
    source &&
    typeof source === 'object' &&
    [
      'GAME_TEST',
      'REDDIT',
      'WIKI',
      'YOUTUBE',
      'JEANROPKE_MAP',
      'FRONTIER_ALGORITHM',
      'COMMUNITY_TESTED',
      'CALCULATED',
    ].includes(source.type) &&
    typeof source.date === 'string' &&
    /^\d{4}-\d{2}-\d{2}$/.test(source.date)
  );
}

function sanitizeSources(sources: any[]): SourceRef[] {
  if (!Array.isArray(sources)) return [];
  return sources.filter(validateSourceRef);
}

function toISODate(date?: string | Date): string {
  if (!date) return new Date().toISOString().split('T')[0];
  if (typeof date === 'string') return date;
  return date.toISOString().split('T')[0];
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MIGRATION RESULT TYPES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export interface MigrationStats {
  items_migrated: number;
  formulas_migrated: number;
  animals_migrated: number;
  fast_travel_nodes: number;
  fast_travel_routes: number;
  collector_items: number;
  roles_migrated: number;
  high_confidence_items: number;
  medium_confidence_items: number;
  low_confidence_items: number;
}

export interface MigrationReport {
  success: boolean;
  timestamp: string;
  stats: MigrationStats;
  warnings: string[];
  errors: string[];
  gaps: string[];
  summary: string;
}

export interface MigratedData {
  items: Record<string, RDOItem>;
  formulas: Record<string, EconomicFormula>;
  animals: Record<string, Animal>;
  fast_travel_nodes: Record<string, FastTravelNode>;
  fast_travel_routes: FastTravelRoute[];
  collector_items: Record<string, CollectorItem>;
  roles: Record<string, Role>;
  report: MigrationReport;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CORE MIGRATOR CLASS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export class V2ToV3Migrator {
  private warnings: string[] = [];
  private errors: string[] = [];
  private gaps: string[] = [];
  private highConfidence = 0;
  private mediumConfidence = 0;
  private lowConfidence = 0;

  /**
   * Main entry point: migrate entire v2 extraction log
   */
  migrate(v2Data: any): MigratedData {
    this.warnings = [];
    this.errors = [];
    this.gaps = [];
    this.highConfidence = 0;
    this.mediumConfidence = 0;
    this.lowConfidence = 0;

    const result: MigratedData = {
      items: {},
      formulas: {},
      animals: {},
      fast_travel_nodes: {},
      fast_travel_routes: [],
      collector_items: {},
      roles: {},
      report: {
        success: false,
        timestamp: new Date().toISOString(),
        stats: {
          items_migrated: 0,
          formulas_migrated: 0,
          animals_migrated: 0,
          fast_travel_nodes: 0,
          fast_travel_routes: 0,
          collector_items: 0,
          roles_migrated: 0,
          high_confidence_items: 0,
          medium_confidence_items: 0,
          low_confidence_items: 0,
        },
        warnings: [],
        errors: [],
        gaps: [],
        summary: '',
      },
    };

    try {
      // Migrate each domain
      if (v2Data.items) {
        const migratedItems = this.migrateItems(v2Data.items);
        Object.entries(migratedItems).forEach(([id, item]) => {
          result.items[id] = item;
        });
        result.report.stats.items_migrated = Object.keys(result.items).length;
      }

      if (v2Data.economic_formulas) {
        const migratedFormulas = this.migrateFormulas(v2Data.economic_formulas);
        Object.entries(migratedFormulas).forEach(([id, formula]) => {
          result.formulas[id] = formula;
        });
        result.report.stats.formulas_migrated = Object.keys(
          result.formulas
        ).length;
      }

      if (v2Data.animals) {
        const migratedAnimals = this.migrateAnimals(v2Data.animals);
        Object.entries(migratedAnimals).forEach(([id, animal]) => {
          result.animals[id] = animal;
        });
        result.report.stats.animals_migrated = Object.keys(
          result.animals
        ).length;
      }

      if (v2Data.fast_travel_nodes) {
        const migratedNodes = this.migrateFastTravelNodes(
          v2Data.fast_travel_nodes
        );
        Object.entries(migratedNodes).forEach(([id, node]) => {
          result.fast_travel_nodes[id] = node;
        });
        result.report.stats.fast_travel_nodes = Object.keys(
          result.fast_travel_nodes
        ).length;
      }

      if (v2Data.fast_travel_routes) {
        result.fast_travel_routes = this.migrateFastTravelRoutes(
          v2Data.fast_travel_routes
        );
        result.report.stats.fast_travel_routes =
          result.fast_travel_routes.length;
      }

      if (v2Data.collector_items) {
        const migratedCollectors = this.migrateCollectorItems(
          v2Data.collector_items
        );
        Object.entries(migratedCollectors).forEach(([id, item]) => {
          result.collector_items[id] = item;
        });
        result.report.stats.collector_items = Object.keys(
          result.collector_items
        ).length;
      }

      if (v2Data.roles) {
        const migratedRoles = this.migrateRoles(v2Data.roles);
        Object.entries(migratedRoles).forEach(([id, role]) => {
          result.roles[id] = role;
        });
        result.report.stats.roles_migrated = Object.keys(result.roles).length;
      }

      // Confidence stats
      result.report.stats.high_confidence_items = this.highConfidence;
      result.report.stats.medium_confidence_items = this.mediumConfidence;
      result.report.stats.low_confidence_items = this.lowConfidence;

      result.report.success = this.errors.length === 0;
      result.report.warnings = this.warnings;
      result.report.errors = this.errors;
      result.report.gaps = this.gaps;

      // Generate summary
      result.report.summary = this.generateSummary(result.report);

      return result;
    } catch (err) {
      this.errors.push(`Critical migration failure: ${(err as Error).message}`);
      result.report.success = false;
      result.report.errors = this.errors;
      result.report.summary = `FAILED: ${this.errors[0]}`;
      return result;
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DOMAIN-SPECIFIC MIGRATORS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  private migrateItems(v2Items: any[]): Record<string, RDOItem> {
    const items: Record<string, RDOItem> = {};

    for (const v2Item of v2Items) {
      try {
        // Validate required fields
        if (!v2Item.id || !v2Item.name) {
          this.errors.push(
            `Item missing id or name: ${JSON.stringify(v2Item).substring(0, 100)}`
          );
          continue;
        }

        // Validate sources
        const sources = sanitizeSources(v2Item.sources || []);
        if ((v2Item.sources || []).length > 0 && sources.length === 0) {
          this.warnings.push(
            `Item ${v2Item.id}: Invalid source references found, using empty sources`
          );
        }

        const confidence = inferConfidence(sources);
        if (confidence === 'HIGH') this.highConfidence++;
        else if (confidence === 'MEDIUM') this.mediumConfidence++;
        else this.lowConfidence++;

        if (confidence === 'LOW') {
          this.gaps.push(`Item ${v2Item.id}: Low confidence, needs verification`);
        }

        const item: RDOItem = {
          id: v2Item.id,
          name: v2Item.name,
          category: (v2Item.category || 'weapon') as ItemCategory,
          shop: (v2Item.shop || 'general_store') as ItemShop,
          price: {
            cash: v2Item.price
              ? {
                  value: v2Item.price,
                  confidence,
                  sources,
                  last_verified: toISODate(v2Item.last_verified),
                  patch_version: v2Item.patch_version || 'UNKNOWN',
                }
              : undefined,
            gold: v2Item.gold_price
              ? {
                  value: v2Item.gold_price,
                  confidence,
                  sources,
                  last_verified: toISODate(v2Item.last_verified),
                  patch_version: v2Item.patch_version || 'UNKNOWN',
                }
              : undefined,
          },
          rarity: v2Item.rarity,
          description: v2Item.description,
          type: v2Item.type,
          stats: v2Item.stats,
          confidence,
          sources,
          last_verified: toISODate(v2Item.last_verified),
          patch_version: v2Item.patch_version || 'UNKNOWN',
        };

        items[v2Item.id] = item;
      } catch (err) {
        this.errors.push(
          `Failed to migrate item ${v2Item.id}: ${(err as Error).message}`
        );
      }
    }

    return items;
  }

  private migrateFormulas(v2Formulas: any[]): Record<string, EconomicFormula> {
    const formulas: Record<string, EconomicFormula> = {};

    for (const v2Formula of v2Formulas) {
      try {
        if (!v2Formula.id || !v2Formula.system) {
          this.errors.push(
            `Formula missing id or system: ${JSON.stringify(v2Formula).substring(0, 100)}`
          );
          continue;
        }

        const sources = sanitizeSources(v2Formula.sources || []);
        const confidence = inferConfidence(sources);

        if (confidence === 'HIGH') this.highConfidence++;
        else if (confidence === 'MEDIUM') this.mediumConfidence++;
        else this.lowConfidence++;

        formulas[v2Formula.id] = {
          id: v2Formula.id,
          system: v2Formula.system,
          name: v2Formula.name || v2Formula.id,
          formula: v2Formula.formula || 'UNKNOWN',
          description: v2Formula.description,
          variables: v2Formula.variables || [],
          optimal_parameters: v2Formula.optimal_parameters,
          examples: v2Formula.examples || [],
          confidence,
          sources,
          patch_version: v2Formula.patch_version || 'UNKNOWN',
          last_verified: toISODate(v2Formula.last_verified),
        };
      } catch (err) {
        this.errors.push(
          `Failed to migrate formula ${v2Formula.id}: ${(err as Error).message}`
        );
      }
    }

    return formulas;
  }

  private migrateAnimals(v2Animals: any[]): Record<string, Animal> {
    const animals: Record<string, Animal> = {};

    for (const v2Animal of v2Animals) {
      try {
        if (!v2Animal.id || !v2Animal.name) {
          this.errors.push(
            `Animal missing id or name: ${JSON.stringify(v2Animal).substring(0, 100)}`
          );
          continue;
        }

        const sources = sanitizeSources(v2Animal.sources || []);
        const confidence = inferConfidence(sources);

        if (confidence === 'HIGH') this.highConfidence++;
        else if (confidence === 'MEDIUM') this.mediumConfidence++;
        else this.lowConfidence++;

        animals[v2Animal.id] = {
          id: v2Animal.id,
          name: v2Animal.name,
          species: v2Animal.species || 'Unknown',
          size: v2Animal.size || 'medium',
          ai_rating: {
            value: v2Animal.ai_rating || 5,
            confidence,
            sources,
            last_verified: toISODate(v2Animal.last_verified),
            patch_version: v2Animal.patch_version || 'UNKNOWN',
          },
          health: {
            value: v2Animal.health || 100,
            confidence,
            sources,
            last_verified: toISODate(v2Animal.last_verified),
            patch_version: v2Animal.patch_version || 'UNKNOWN',
          },
          materials: v2Animal.materials || [],
          spawns: v2Animal.spawns || [],
          can_study: v2Animal.can_study || false,
          confidence,
          sources,
          last_verified: toISODate(v2Animal.last_verified),
          patch_version: v2Animal.patch_version || 'UNKNOWN',
        };
      } catch (err) {
        this.errors.push(
          `Failed to migrate animal ${v2Animal.id}: ${(err as Error).message}`
        );
      }
    }

    return animals;
  }

  private migrateFastTravelNodes(v2Nodes: any[]): Record<string, FastTravelNode> {
    const nodes: Record<string, FastTravelNode> = {};

    for (const node of v2Nodes) {
      try {
        if (!node.id || !node.name) {
          this.warnings.push(
            `Fast travel node missing id or name: ${JSON.stringify(node).substring(0, 100)}`
          );
          continue;
        }

        const sources = sanitizeSources(node.sources || []);
        const confidence = inferConfidence(sources);

        nodes[node.id] = {
          id: node.id,
          name: node.name,
          latitude: {
            value: node.latitude || 0,
            confidence,
            sources,
            last_verified: toISODate(node.last_verified),
          },
          longitude: {
            value: node.longitude || 0,
            confidence,
            sources,
            last_verified: toISODate(node.last_verified),
          },
          region: node.region || 'Unknown',
          cost_cash: {
            value: node.cost_cash || 0,
            confidence,
            sources,
            last_verified: toISODate(node.last_verified),
          },
          confidence,
          sources,
          last_verified: toISODate(node.last_verified),
        };
      } catch (err) {
        this.errors.push(
          `Failed to migrate fast travel node ${node.id}: ${(err as Error).message}`
        );
      }
    }

    return nodes;
  }

  private migrateFastTravelRoutes(v2Routes: any[]): FastTravelRoute[] {
    const routes: FastTravelRoute[] = [];

    for (const route of v2Routes) {
      try {
        if (!route.from_node_id || !route.to_node_id) {
          this.warnings.push(
            `Fast travel route missing nodes: ${JSON.stringify(route).substring(0, 100)}`
          );
          continue;
        }

        const sources = sanitizeSources(route.sources || []);
        const confidence = inferConfidence(sources);

        routes.push({
          id: route.id || `${route.from_node_id}_to_${route.to_node_id}`,
          from_node_id: route.from_node_id,
          to_node_id: route.to_node_id,
          distance_miles: {
            value: route.distance_miles || 0,
            confidence,
            sources,
            last_verified: toISODate(route.last_verified),
          },
          travel_time_seconds: {
            value: route.travel_time_seconds || 0,
            confidence,
            sources,
            last_verified: toISODate(route.last_verified),
          },
          cost_cash: {
            value: route.cost_cash || 0,
            confidence,
            sources,
            last_verified: toISODate(route.last_verified),
          },
          asymmetric: route.asymmetric || false,
          confidence,
          sources,
          last_verified: toISODate(route.last_verified),
        });
      } catch (err) {
        this.errors.push(
          `Failed to migrate fast travel route: ${(err as Error).message}`
        );
      }
    }

    return routes;
  }

  private migrateCollectorItems(
    v2Items: any[]
  ): Record<string, CollectorItem> {
    const items: Record<string, CollectorItem> = {};

    for (const item of v2Items) {
      try {
        if (!item.id || !item.collection_set) {
          this.warnings.push(
            `Collector item missing id or set: ${JSON.stringify(item).substring(0, 100)}`
          );
          continue;
        }

        const sources = sanitizeSources(item.sources || []);
        const confidence = inferConfidence(sources);

        if (confidence === 'HIGH') this.highConfidence++;
        else if (confidence === 'MEDIUM') this.mediumConfidence++;
        else this.lowConfidence++;

        items[item.id] = {
          id: item.id,
          collection_set: item.collection_set,
          cycle: {
            value: item.cycle || 1,
            confidence,
            sources,
            last_verified: toISODate(item.last_verified),
          },
          name: item.name || item.id,
          description: item.description,
          latitude: {
            value: item.latitude || 0,
            confidence,
            sources,
            last_verified: toISODate(item.last_verified),
          },
          longitude: {
            value: item.longitude || 0,
            confidence,
            sources,
            last_verified: toISODate(item.last_verified),
          },
          region: item.region || 'Unknown',
          cash_value: {
            value: item.cash_value || 0,
            confidence,
            sources,
            last_verified: toISODate(item.last_verified),
          },
          confidence,
          sources,
          last_verified: toISODate(item.last_verified),
          patch_version: item.patch_version || 'UNKNOWN',
        };
      } catch (err) {
        this.errors.push(
          `Failed to migrate collector item ${item.id}: ${(err as Error).message}`
        );
      }
    }

    return items;
  }

  private migrateRoles(v2Roles: any[]): Record<string, Role> {
    const roles: Record<string, Role> = {};

    for (const role of v2Roles) {
      try {
        if (!role.id || !role.name) {
          this.warnings.push(
            `Role missing id or name: ${JSON.stringify(role).substring(0, 100)}`
          );
          continue;
        }

        const sources = sanitizeSources(role.sources || []);
        const confidence = inferConfidence(sources);

        roles[role.id] = {
          id: role.id as any,
          name: role.name,
          mentor_npc: role.mentor_npc,
          unlock_cost_gold: {
            value: role.unlock_cost_gold || 15,
            confidence,
            sources,
            last_verified: toISODate(role.last_verified),
          },
          player_rank_required: {
            value: role.player_rank_required || 5,
            confidence,
            sources,
            last_verified: toISODate(role.last_verified),
          },
          max_rank: {
            value: role.max_rank || 20,
            confidence,
            sources,
            last_verified: toISODate(role.last_verified),
          },
          rank_benefits: role.rank_benefits || [],
          confidence,
          sources,
          last_verified: toISODate(role.last_verified),
        };
      } catch (err) {
        this.errors.push(
          `Failed to migrate role ${role.id}: ${(err as Error).message}`
        );
      }
    }

    return roles;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // REPORT GENERATION
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  private generateSummary(report: MigrationReport): string {
    const {
      stats: {
        items_migrated,
        formulas_migrated,
        animals_migrated,
        roles_migrated,
        high_confidence_items,
        low_confidence_items,
      },
      errors,
      warnings,
      gaps,
    } = report;

    const totalItems = items_migrated + formulas_migrated + animals_migrated + roles_migrated;

    let summary = `âœ… MIGRATION COMPLETE\n`;
    summary += `Migrated ${totalItems} total entries (${items_migrated} items, ${formulas_migrated} formulas, ${animals_migrated} animals, ${roles_migrated} roles)\n`;
    summary += `Confidence: ${high_confidence_items} HIGH, ${Math.max(0, this.mediumConfidence)} MEDIUM, ${low_confidence_items} LOW\n`;

    if (errors.length > 0) {
      summary += `âŒ ${errors.length} errors found\n`;
    }
    if (warnings.length > 0) {
      summary += `âš ï¸  ${warnings.length} warnings\n`;
    }
    if (gaps.length > 0) {
      summary += `ðŸ” ${gaps.length} data gaps (unverified entries)\n`;
    }

    return summary;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONVENIENCE EXPORT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export function migrateV2ToV3(v2Data: any): MigratedData {
  const migrator = new V2ToV3Migrator();
  return migrator.migrate(v2Data);
}

export default { V2ToV3Migrator, migrateV2ToV3 };

#!/usr/bin/env node
/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * V2 TO V3 MIGRATION RUNNER
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 * Usage:
 *   npm run migrate                  # Run migration with default path
 *   npm run migrate -- data/custom.json  # Run with custom input file
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { migrateV2ToV3 } from '../migration/v2_to_v3_migrator.js';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONFIGURATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Get input file from args or use default
const inputFile = process.argv[2] || 'rdo_extraction_log.json';
const inputPath = path.resolve(__dirname, '../../data', inputFile);
const outputDir = path.resolve(__dirname, '../../data/v3');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

console.log('\nðŸŽ¯ RDO V2â†’V3 MIGRATION ENGINE\n');
console.log(`ðŸ“‚ Input:  ${inputPath}`);
console.log(`ðŸ“‚ Output: ${outputDir}\n`);

// Validate input file exists
if (!fs.existsSync(inputPath)) {
  console.error(`âŒ Input file not found: ${inputPath}`);
  process.exit(1);
}

// Read v2 extraction log
let v2Data: any;
try {
  const rawData = fs.readFileSync(inputPath, 'utf-8');
  v2Data = JSON.parse(rawData);
  console.log(`âœ… Loaded input file (${rawData.length} bytes)`);
} catch (err) {
  console.error(`âŒ Failed to parse input file: ${(err as Error).message}`);
  process.exit(1);
}

// Run migration
console.log('\nðŸ”„ Running migration...\n');
const result = migrateV2ToV3(v2Data);

// Create output directory
if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir, { recursive: true });
  console.log(`ðŸ“ Created output directory`);
}

// Save migrated data
try {
  const compendiumPath = path.join(outputDir, 'compendium.json');
  const economicsPath = path.join(outputDir, 'economics.json');
  const reportPath = path.join(outputDir, 'migration_report.json');

  fs.writeFileSync(
    compendiumPath,
    JSON.stringify(
      {
        items: result.items,
        animals: result.animals,
        fast_travel_nodes: result.fast_travel_nodes,
        fast_travel_routes: result.fast_travel_routes,
        collector_items: result.collector_items,
        roles: result.roles,
      },
      null,
      2
    )
  );
  console.log(`âœ… Saved compendium: ${compendiumPath}`);

  fs.writeFileSync(
    economicsPath,
    JSON.stringify(
      {
        formulas: result.formulas,
      },
      null,
      2
    )
  );
  console.log(`âœ… Saved economics: ${economicsPath}`);

  fs.writeFileSync(reportPath, JSON.stringify(result.report, null, 2));
  console.log(`âœ… Saved report: ${reportPath}`);
} catch (err) {
  console.error(`âŒ Failed to write output files: ${(err as Error).message}`);
  process.exit(1);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REPORT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

console.log('\n' + 'â•'.repeat(70));
console.log('MIGRATION REPORT');
console.log('â•'.repeat(70) + '\n');

const {
  stats,
  success,
  warnings,
  errors,
  gaps,
  timestamp,
  summary,
} = result.report;

console.log(summary);

console.log('\nðŸ“Š STATISTICS:\n');
console.log(`  Items:          ${stats.items_migrated}`);
console.log(`  Formulas:       ${stats.formulas_migrated}`);
console.log(`  Animals:        ${stats.animals_migrated}`);
console.log(`  Fast Travel:    ${stats.fast_travel_nodes}`);
console.log(`  Collector:      ${stats.collector_items}`);
console.log(`  Roles:          ${stats.roles_migrated}`);
console.log(`  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`);
console.log(
  `  TOTAL:          ${stats.items_migrated + stats.formulas_migrated + stats.animals_migrated + stats.fast_travel_nodes + stats.collector_items + stats.roles_migrated}`
);

console.log('\nðŸ“ˆ CONFIDENCE:\n');
console.log(`  ðŸŸ¢ HIGH:        ${stats.high_confidence_items}`);
console.log(`  ðŸŸ¡ MEDIUM:      ${stats.medium_confidence_items}`);
console.log(`  ðŸ”´ LOW:         ${stats.low_confidence_items}`);

if (errors.length > 0) {
  console.log(`\nâŒ ERRORS (${errors.length}):\n`);
  errors.slice(0, 5).forEach((err, i) => {
    console.log(`  ${i + 1}. ${err}`);
  });
  if (errors.length > 5) {
    console.log(`  ... and ${errors.length - 5} more`);
  }
}

if (warnings.length > 0) {
  console.log(`\nâš ï¸  WARNINGS (${warnings.length}):\n`);
  warnings.slice(0, 5).forEach((warn, i) => {
    console.log(`  ${i + 1}. ${warn}`);
  });
  if (warnings.length > 5) {
    console.log(`  ... and ${warnings.length - 5} more`);
  }
}

if (gaps.length > 0) {
  console.log(`\nðŸ” DATA GAPS (${gaps.length} entries need verification):\n`);
  gaps.slice(0, 5).forEach((gap, i) => {
    console.log(`  ${i + 1}. ${gap}`);
  });
  if (gaps.length > 5) {
    console.log(`  ... and ${gaps.length - 5} more`);
  }
}

console.log('\nâ±ï¸  Timestamp: ' + timestamp);
console.log('\n' + 'â•'.repeat(70) + '\n');

if (success) {
  console.log('âœ… Migration successful! Data ready for Redux store.\n');
  process.exit(0);
} else {
  console.log('âŒ Migration completed with errors. Review report above.\n');
  process.exit(1);
}

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * BOUNTY HUNTER CALCULATOR - Pure Economic Functions
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * Implements the Bounty Hunter payout formulas from the Frontier Algorithm.
 * All functions are pure (no side effects, deterministic).
 * 
 * Core Formula:
 *   Cash = B Ã— M_tier Ã— M_status Ã— M_time Ã— M_count
 *   Gold = TimeBonus(minutes)
 *   XP   = BaseXP Ã— RankMultiplier
 */

import {
  BOUNTY_PAYOUT_BASE_CASH,
  BOUNTY_PAYOUT_TIER_MULTIPLIERS,
  BOUNTY_PAYOUT_STATUS_MULTIPLIERS,
  BOUNTY_PAYOUT_TARGET_MULTIPLIERS,
  BOUNTY_GOLD_TIME_BONUS,
  BOUNTY_XP_BASE,
} from '../domain/gameData.constants';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INPUT & OUTPUT TYPES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export interface BountyPayoutInput {
  /** Base cash amount before multipliers */
  baseCash?: number;
  
  /** Bounty tier: 1 ($), 2 ($$), 3 ($$$) */
  tier: 1 | 2 | 3;
  
  /** True if all targets captured alive; false if killed */
  alive: boolean;
  
  /** Number of targets: 1, 2, or 3 */
  targetCount: 1 | 2 | 3;
  
  /** Minutes elapsed during bounty (affects gold bonus) */
  minutesElapsed: number;
  
  /** Rank multiplier (role rank bonus, future feature) */
  rankMultiplier?: number;
}

export interface BountyPayoutResult {
  /** Total cash earned */
  cash: number;
  
  /** Gold bars earned (time-based bonus) */
  gold: number;
  
  /** Total experience points */
  xp: number;
  
  /** Effective cash per hour */
  cash_per_hour: number;
  
  /** Effective gold per hour */
  gold_per_hour: number;
  
  /** Breakdown of calculation for transparency */
  breakdown?: {
    base_cash: number;
    tier_multiplier: number;
    status_multiplier: number;
    target_multiplier: number;
    rank_multiplier: number;
    time_bonus_gold: number;
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GOLD TIME BONUS CALCULATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Calculates gold bar bonus based on mission completion time.
 * 
 * Rules:
 * - 0-12 min: 0.08 gold per 3 minutes (up to 0.32 gold)
 * - 12-15 min: 0.04 gold additional
 * - 15-30 min: 0.04 gold per 5 minutes
 * - 30+ min: No additional gold
 * 
 * This creates a curve that rewards quick completion while allowing
 * flexibility for methodical plays.
 * 
 * @example
 * calculateGoldTimeBonus(12) // â†’ 0.32 (optimal)
 * calculateGoldTimeBonus(6)  // â†’ 0.16 (half time)
 * calculateGoldTimeBonus(30) // â†’ 0.48 (max)
 */
export function calculateGoldTimeBonus(minutesElapsed: number): number {
  const { base_increment, window_minutes, optimal_duration_minutes, optimal_gold, post_optimal_increment, post_optimal_window } =
    BOUNTY_GOLD_TIME_BONUS;

  if (minutesElapsed <= 0) return 0;
  if (minutesElapsed > 30) return optimal_gold + 0.04 + (15 / post_optimal_window) * post_optimal_increment;

  // Phase 1: 0-12 minutes (fast bonus)
  if (minutesElapsed <= optimal_duration_minutes) {
    const chunks = Math.floor(minutesElapsed / window_minutes);
    const partial = (minutesElapsed % window_minutes) / window_minutes;
    return chunks * base_increment + partial * base_increment;
  }

  // Phase 2: 12-15 minutes (transition)
  if (minutesElapsed <= 15) {
    return optimal_gold + (minutesElapsed - optimal_duration_minutes) * (post_optimal_increment / 3);
  }

  // Phase 3: 15-30 minutes (slow bonus)
  const blocksAfter15 = Math.floor((minutesElapsed - 15) / post_optimal_window);
  const partialAfter15 = ((minutesElapsed - 15) % post_optimal_window) / post_optimal_window;
  return optimal_gold + 0.04 + blocksAfter15 * post_optimal_increment + partialAfter15 * post_optimal_increment;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN PAYOUT CALCULATOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Calculate total bounty payout (cash, gold, XP).
 * 
 * The formula combines all multipliers into a single effective rate:
 *   Cash = B Ã— M_tier Ã— M_status Ã— M_targets Ã— (optional: M_rank)
 * 
 * Gold is calculated separately based on time completion.
 * XP depends on bounty difficulty and role rank (if applicable).
 * 
 * @example
 * // Single-target, alive, tier 2, completed in 10 minutes
 * const result = calculateBountyPayout({
 *   tier: 2,
 *   alive: true,
 *   targetCount: 1,
 *   minutesElapsed: 10
 * });
 * // â†’ { cash: 37.5, gold: 0.24, xp: 50, ... }
 */
export function calculateBountyPayout(input: BountyPayoutInput): BountyPayoutResult {
  // === INPUT VALIDATION (CRITICAL FIX) ===
  if (![1, 2, 3].includes(input.tier)) {
    throw new Error(`Invalid tier: ${input.tier}. Must be 1, 2, or 3.`);
  }
  if (![1, 2, 3].includes(input.targetCount)) {
    throw new Error(`Invalid targetCount: ${input.targetCount}. Must be 1, 2, or 3.`);
  }
  if (typeof input.minutesElapsed !== 'number' || input.minutesElapsed < 0 || input.minutesElapsed > 60) {
    throw new Error(`Invalid minutesElapsed: ${input.minutesElapsed}. Must be 0-60 minutes.`);
  }
  if (typeof input.alive !== 'boolean') {
    throw new Error(`Invalid alive: ${input.alive}. Must be true or false.`);
  }

  const {
    baseCash = BOUNTY_PAYOUT_BASE_CASH,
    tier,
    alive,
    targetCount,
    minutesElapsed,
    rankMultiplier = 1.0,
  } = input;

  // Fetch multipliers from constants
  const tierMultiplier = BOUNTY_PAYOUT_TIER_MULTIPLIERS[tier];
  const statusMultiplier = alive
    ? BOUNTY_PAYOUT_STATUS_MULTIPLIERS.alive
    : BOUNTY_PAYOUT_STATUS_MULTIPLIERS.dead;
  const targetMultiplier = BOUNTY_PAYOUT_TARGET_MULTIPLIERS[targetCount];

  // Calculate cash
  const cash = baseCash * tierMultiplier * statusMultiplier * targetMultiplier * rankMultiplier;

  // Calculate gold bonus
  const gold = calculateGoldTimeBonus(minutesElapsed);

  // Calculate XP (simplified; expand with rank-based bonuses)
  const xp = BOUNTY_XP_BASE.cash_kill * targetCount;

  // Rates per hour
  const hoursElapsed = Math.max(minutesElapsed / 60, 0.01); // Avoid division by zero
  const cash_per_hour = cash / hoursElapsed;
  const gold_per_hour = gold / hoursElapsed;

  return {
    cash: Math.round(cash * 100) / 100, // Round to 2 decimals
    gold: Math.round(gold * 100) / 100,
    xp,
    cash_per_hour: Math.round(cash_per_hour * 100) / 100,
    gold_per_hour: Math.round(gold_per_hour * 100) / 100,
    breakdown: {
      base_cash: baseCash,
      tier_multiplier: tierMultiplier,
      status_multiplier: statusMultiplier,
      target_multiplier: targetMultiplier,
      rank_multiplier: rankMultiplier,
      time_bonus_gold: gold,
    },
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SESSION SIMULATOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export interface BountySessionConfig {
  /** Duration in hours */
  sessionHours: number;

  /** Average minutes per bounty */
  avgBountyMinutes: number;

  /** Distribution: what % of bounties are tier 1/2/3 */
  tierDistribution: {
    tier1: number; // 0.0-1.0
    tier2: number;
    tier3: number;
  };

  /** What % of bounties completed alive vs killed */
  aliveCompletionRate: number; // 0.0-1.0

  /** Role rank multiplier (if applicable) */
  roleRankMultiplier?: number;
}

export interface BountySessionResult {
  total_cash: number;
  total_gold: number;
  total_xp: number;
  bounties_completed: number;
  avg_cash_per_hour: number;
  avg_gold_per_hour: number;
}

/**
 * Simulate a full bounty hunting session.
 * Useful for comparing playstyles and estimating session income.
 * 
 * @example
 * // "I do 2-hour sessions, mostly tier 2, 60% completion alive"
 * const session = simulateBountySession({
 *   sessionHours: 2,
 *   avgBountyMinutes: 15,
 *   tierDistribution: { tier1: 0.2, tier2: 0.6, tier3: 0.2 },
 *   aliveCompletionRate: 0.6
 * });
 * // â†’ { total_cash: 450, total_gold: 3.2, bounties_completed: 8, ... }
 */
export function simulateBountySession(config: BountySessionConfig): BountySessionResult {
  const { sessionHours, avgBountyMinutes, tierDistribution, aliveCompletionRate, roleRankMultiplier = 1.0 } = config;

  const totalMinutes = sessionHours * 60;
  const bountiesCompleted = Math.floor(totalMinutes / avgBountyMinutes);

  let totalCash = 0;
  let totalGold = 0;
  let totalXp = 0;

  // Simulate each bounty
  for (let i = 0; i < bountiesCompleted; i++) {
    // Randomly select tier based on distribution
    const rand = Math.random();
    let tier: 1 | 2 | 3 = 1;
    if (rand < tierDistribution.tier1) {
      tier = 1;
    } else if (rand < tierDistribution.tier1 + tierDistribution.tier2) {
      tier = 2;
    } else {
      tier = 3;
    }

    // Determine if alive
    const alive = Math.random() < aliveCompletionRate;

    // Calculate single bounty
    const payout = calculateBountyPayout({
      tier,
      alive,
      targetCount: 1,
      minutesElapsed: avgBountyMinutes,
      rankMultiplier: roleRankMultiplier,
    });

    totalCash += payout.cash;
    totalGold += payout.gold;
    totalXp += payout.xp;
  }

  return {
    total_cash: Math.round(totalCash * 100) / 100,
    total_gold: Math.round(totalGold * 100) / 100,
    total_xp: totalXp,
    bounties_completed: bountiesCompleted,
    avg_cash_per_hour: Math.round((totalCash / sessionHours) * 100) / 100,
    avg_gold_per_hour: Math.round((totalGold / sessionHours) * 100) / 100,
  };
}

export default {
  calculateGoldTimeBonus,
  calculateBountyPayout,
  simulateBountySession,
};

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * TRADER CALCULATOR - Pure Economic Functions
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * Implements the Trader role income formulas:
 * 1. Hunt materials â†’ materials (loot)
 * 2. Accumulate materials â†’ goods (Cripps conversion)
 * 3. Sell goods to buyers â†’ cash (with time/distance bonuses)
 * 
 * Pure functions for transparent economics modeling.
 */

import {
  TRADER_MATERIAL_PAYOUTS,
  TRADER_GOODS_CONVERSION,
  TRADER_WAGON_CAPACITY,
  TRADER_SESSION_EFFICIENCY,
} from '../domain/gameData.constants';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INPUT & OUTPUT TYPES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export interface TraderDeliveryInput {
  /** Amount of goods (0-100 for large wagon) */
  goodsCount: number;

  /** Wagon size: 'small' (50) or 'large' (100) */
  wagonSize: 'small' | 'large';

  /** Minutes taken to deliver goods */
  deliveryTimeMinutes: number;

  /** Approximate distance to buyer (short/medium/long) */
  deliveryDistance: 'short' | 'medium' | 'long';

  /** If true, buyer is far away (rare long-distance bonus) */
  isLongDistance?: boolean;
}

export interface TraderDeliveryResult {
  /** Base payout before bonuses */
  base_cash: number;

  /** Time bonus (delivered within optimal window) */
  time_bonus: number;

  /** Distance bonus (longer trips pay more) */
  distance_bonus: number;

  /** Total cash received */
  total_cash: number;

  /** Effective cash per minute */
  cash_per_minute: number;

  /** Breakdown for transparency */
  breakdown?: {
    goods_count: number;
    base_per_100: number;
    time_bonus_percent: number;
    distance_bonus_percent: number;
  };
}

export interface TraderSessionInput {
  /** Session duration in hours */
  sessionHours: number;

  /** Wagon size: 'small' (50) or 'large' (100) */
  wagonSize: 'small' | 'large';

  /** Number of delivery runs per hour */
  runsPerHour: number;

  /** Typical delivery time (minutes) */
  avgDeliveryMinutes: number;

  /** Average delivery distance */
  avgDeliveryDistance: 'short' | 'medium' | 'long';

  /** How full wagon is per run (0.0-1.0) */
  wagonFillFactor: number;

  /** Cripps conversion efficiency (0.8 = 80% of hunted materials become goods) */
  conversionEfficiency?: number;
}

export interface TraderSessionResult {
  total_cash: number;
  total_goods_delivered: number;
  delivery_runs: number;
  avg_cash_per_run: number;
  avg_cash_per_hour: number;
  materials_needed_to_hunt: number;
  estimated_hunting_time_hours: number;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TIME BONUS CALCULATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Calculates time bonus multiplier for trader delivery.
 * 
 * Optimal window: 0-30 minutes â†’ 1.0x (full payout)
 * Beyond 30 minutes: No additional penalty, but bonus opportunity missed
 * 
 * This incentivizes quick, consistent deliveries but allows flexibility.
 * 
 * @example
 * getTimeBonus(10)  // â†’ 1.0 (optimal)
 * getTimeBonus(30)  // â†’ 1.0 (still in window)
 * getTimeBonus(45)  // â†’ 1.0 (no penalty, just no bonus)
 */
export function getTimeBonus(deliveryTimeMinutes: number): number {
  if (deliveryTimeMinutes <= 30) {
    return 1.0;
  }
  // For times beyond 30 min, there's no additional penalty in the base formula
  // but the reward $75 bonus is lost
  return 1.0;
}

/**
 * Calculates distance bonus multiplier.
 * 
 * Short distance: No inherent bonus (safe, nearby)
 * Medium distance: Typical delivery (expected baseline)
 * Long distance: Premium pay (risk/reward for distant buyers)
 * 
 * Note: This is simplified from actual RDO mechanics.
 * Real game also considers buyer faction and supply level.
 */
export function getDistanceBonus(deliveryDistance: 'short' | 'medium' | 'long'): number {
  switch (deliveryDistance) {
    case 'short':
      return 1.0;
    case 'medium':
      return 1.0; // Baseline
    case 'long':
      return 1.15; // 15% premium
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DELIVERY PAYOUT CALCULATOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Calculate cash payout for a single trader goods delivery.
 * 
 * Base formula:
 *   CashBase = (goods / 100) Ã— $625
 *   CashTotal = CashBase Ã— DistanceMultiplier
 * 
 * Bonuses (capped at $75 + $50 = $125):
 *   - Time bonus: $75 if delivered within 30 minutes
 *   - Distance bonus: $50 if delivery is far (rare)
 * 
 * @example
 * // Deliver 100 goods (large wagon full), 20 min, medium distance
 * const result = calculateTraderDelivery({
 *   goodsCount: 100,
 *   wagonSize: 'large',
 *   deliveryTimeMinutes: 20,
 *   deliveryDistance: 'medium'
 * });
 * // â†’ { base_cash: 625, time_bonus: 75, distance_bonus: 0, total_cash: 700 }
 */
export function calculateTraderDelivery(input: TraderDeliveryInput): TraderDeliveryResult {
  // === INPUT VALIDATION (CRITICAL FIX) ===
  if (typeof input.goodsCount !== 'number' || input.goodsCount < 0 || input.goodsCount > 100) {
    throw new Error(`Invalid goodsCount: ${input.goodsCount}. Must be 0-100.`);
  }
  if (!['small', 'large'].includes(input.wagonSize)) {
    throw new Error(`Invalid wagonSize: ${input.wagonSize}. Must be 'small' or 'large'.`);
  }
  if (typeof input.deliveryTimeMinutes !== 'number' || input.deliveryTimeMinutes < 0 || input.deliveryTimeMinutes > 60) {
    throw new Error(`Invalid deliveryTimeMinutes: ${input.deliveryTimeMinutes}. Must be 0-60.`);
  }
  if (!['short', 'medium', 'long'].includes(input.deliveryDistance)) {
    throw new Error(`Invalid deliveryDistance: ${input.deliveryDistance}. Must be 'short', 'medium', or 'long'.`);
  }

  const { goodsCount, wagonSize, deliveryTimeMinutes, deliveryDistance, isLongDistance } = input;

  const { base_payout_per_100_goods, max_time_bonus, max_distance_bonus } = TRADER_GOODS_CONVERSION;

  // Validate input
  const wagonCap = TRADER_WAGON_CAPACITY[wagonSize];
  const actualGoods = Math.min(goodsCount, wagonCap);

  // Base payout
  const base_cash = (actualGoods / 100) * base_payout_per_100_goods;

  // Time bonus (if delivered within 30 minutes)
  const time_bonus = deliveryTimeMinutes <= 30 ? max_time_bonus : 0;

  // Distance bonus (if delivery is far or flagged as long-distance)
  const distance_bonus = isLongDistance ? max_distance_bonus : 0;

  // Total payout
  const total_cash = base_cash + time_bonus + distance_bonus;

  // Effective rate
  const cash_per_minute = deliveryTimeMinutes > 0 ? total_cash / deliveryTimeMinutes : total_cash;

  return {
    base_cash: Math.round(base_cash * 100) / 100,
    time_bonus,
    distance_bonus,
    total_cash: Math.round(total_cash * 100) / 100,
    cash_per_minute: Math.round(cash_per_minute * 100) / 100,
    breakdown: {
      goods_count: actualGoods,
      base_per_100: base_payout_per_100_goods,
      time_bonus_percent: deliveryTimeMinutes <= 30 ? 100 : 0,
      distance_bonus_percent: isLongDistance ? 100 : 0,
    },
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SESSION SIMULATOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Simulate a full trader session including hunting, goods accumulation, delivery.
 * 
 * Flow:
 * 1. Hunt for X hours â†’ accumulate materials (efficiency-based)
 * 2. Cripps converts materials â†’ goods (1:1 ratio, simplified)
 * 3. Deliver goods â†’ receive cash + bonuses
 * 
 * @example
 * // "I'll hunt for 2 hours then do a delivery run"
 * const session = simulateTraderSession({
 *   sessionHours: 2,
 *   wagonSize: 'large',
 *   runsPerHour: 1,  // One delivery after every hour
 *   avgDeliveryMinutes: 25,
 *   avgDeliveryDistance: 'medium',
 *   wagonFillFactor: 0.9  // 90 goods out of 100
 * });
 * // â†’ { total_cash: 1350, total_goods_delivered: 180, avg_cash_per_hour: 675, ... }
 */
export function simulateTraderSession(input: TraderSessionInput): TraderSessionResult {
  const {
    sessionHours,
    wagonSize,
    runsPerHour,
    avgDeliveryMinutes,
    avgDeliveryDistance,
    wagonFillFactor = 0.9,
    conversionEfficiency = 0.85,
  } = input;

  const wagonCap = TRADER_WAGON_CAPACITY[wagonSize];
  const avgGoodsPerRun = Math.floor(wagonCap * wagonFillFactor);

  // Calculate number of delivery runs
  const deliveryRuns = Math.floor(sessionHours * runsPerHour);

  // Calculate total goods delivered
  const totalGoodsDelivered = avgGoodsPerRun * deliveryRuns;

  // Calculate cash from deliveries
  let totalCash = 0;
  for (let i = 0; i < deliveryRuns; i++) {
    const payout = calculateTraderDelivery({
      goodsCount: avgGoodsPerRun,
      wagonSize,
      deliveryTimeMinutes: avgDeliveryMinutes,
      deliveryDistance: avgDeliveryDistance,
    });
    totalCash += payout.total_cash;
  }

  // Estimate hunting time needed
  // Goods = Materials Ã— conversionEfficiency
  // Materials needed = Goods / conversionEfficiency
  // Hunting rate = avgSessionEfficiency materials per hour
  const materialsNeeded = Math.ceil(totalGoodsDelivered / conversionEfficiency);
  const { avg_materials_per_hour } = TRADER_SESSION_EFFICIENCY;
  const estimatedHuntingTimeHours = materialsNeeded / avg_materials_per_hour;

  return {
    total_cash: Math.round(totalCash * 100) / 100,
    total_goods_delivered: totalGoodsDelivered,
    delivery_runs: deliveryRuns,
    avg_cash_per_run: Math.round((totalCash / deliveryRuns) * 100) / 100,
    avg_cash_per_hour: Math.round((totalCash / sessionHours) * 100) / 100,
    materials_needed_to_hunt: materialsNeeded,
    estimated_hunting_time_hours: Math.round(estimatedHuntingTimeHours * 10) / 10,
  };
}

export default {
  getTimeBonus,
  getDistanceBonus,
  calculateTraderDelivery,
  simulateTraderSession,
};

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * BOUNTY CALCULATOR EXAMPLE - UX Integration of Safe Calculations
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * This component demonstrates how to use the useCalculator hook to handle
 * validation errors gracefully without crashing the entire app.
 * 
 * Copy this pattern for other calculators (trader, moonshiner, etc.)
 */

import React, { useState } from 'react';
import { calculateBountyPayout } from '../simulator/bountyHunter';
import { useCalculator } from '../hooks/useCalculator';

export const BountyCalculatorPanel: React.FC = () => {
  // === User input state ===
  const [tier, setTier] = useState<1 | 2 | 3>(2);
  const [alive, setAlive] = useState(true);
  const [targetCount, setTargetCount] = useState<1 | 2 | 3>(1);
  const [minutesElapsed, setMinutesElapsed] = useState(12);

  // === Safe calculator with local error handling ===
  const { result, error, calculate } = useCalculator(calculateBountyPayout);

  // Handle calculate button click
  const handleCalculate = () => {
    calculate({
      tier,
      alive,
      targetCount,
      minutesElapsed,
    });
  };

  return (
    <div className="bg-[#121212] border border-white/10 rounded-lg p-6 max-w-md">
      <h2 className="text-[#D4AF37] font-serif font-bold text-xl mb-6">
        Bounty Calculator
      </h2>

      {/* Input Controls */}
      <div className="space-y-4 mb-6">
        {/* Tier Selector */}
        <div>
          <label className="text-xs text-gray-500 uppercase mb-2 block">
            Bounty Tier
          </label>
          <div className="flex gap-2">
            {[1, 2, 3].map((t) => (
              <button
                key={t}
                onClick={() => setTier(t as 1 | 2 | 3)}
                className={`flex-1 py-2 rounded text-sm font-bold transition-all ${
                  tier === t
                    ? 'bg-[#D4AF37] text-black'
                    : 'bg-white/5 text-gray-400 hover:bg-white/10'
                }`}
              >
                {'$'.repeat(t)}
              </button>
            ))}
          </div>
        </div>

        {/* Alive Status */}
        <div>
          <label className="text-xs text-gray-500 uppercase mb-2 block">
            Capture Status
          </label>
          <button
            onClick={() => setAlive(!alive)}
            className={`w-full py-2 rounded text-sm font-bold transition-all ${
              alive
                ? 'bg-green-900/30 text-green-400 border border-green-500'
                : 'bg-red-900/30 text-red-400 border border-red-500'
            }`}
          >
            {alive ? 'âœ“ ALIVE BONUS' : 'â˜  KILLED'}
          </button>
        </div>

        {/* Target Count */}
        <div>
          <label className="text-xs text-gray-500 uppercase mb-2 block">
            Target Count: {targetCount}
          </label>
          <input
            type="range"
            min="1"
            max="3"
            value={targetCount}
            onChange={(e) => setTargetCount(parseInt(e.target.value) as 1 | 2 | 3)}
            className="w-full accent-[#D4AF37]"
          />
        </div>

        {/* Minutes Elapsed */}
        <div>
          <label className="text-xs text-gray-500 uppercase mb-2 block">
            Time: {minutesElapsed} minutes
          </label>
          <input
            type="range"
            min="0"
            max="60"
            value={minutesElapsed}
            onChange={(e) => setMinutesElapsed(parseInt(e.target.value))}
            className="w-full accent-[#D4AF37]"
          />
        </div>
      </div>

      {/* === FIX 2: Display validation errors locally (no crash) === */}
      {error && (
        <div className="mb-6 p-3 bg-red-900/20 border border-red-500/50 rounded">
          <div className="text-red-400 text-sm">
            <strong>âš ï¸ Validation Error:</strong> {error}
          </div>
          <div className="text-red-300 text-xs mt-1">
            Check your inputs and try again
          </div>
        </div>
      )}

      {/* Calculate Button */}
      <button
        onClick={handleCalculate}
        className="w-full py-3 bg-[#D4AF37] text-black rounded font-bold hover:bg-[#B8941F] transition-all mb-6"
      >
        Calculate Payout
      </button>

      {/* Results Display */}
      {result && !error && (
        <div className="space-y-3">
          <div className="flex justify-between">
            <span className="text-gray-400">Cash:</span>
            <span className="text-[#F5DEB3] font-bold">${result.cash.toFixed(2)}</span>
          </div>
          <div className="flex justify-between">
            <span className="text-gray-400">Gold:</span>
            <span className="text-[#D4AF37] font-bold">{result.gold.toFixed(2)} GB</span>
          </div>
          <div className="flex justify-between">
            <span className="text-gray-400">XP:</span>
            <span className="text-green-400 font-bold">{result.xp}</span>
          </div>
          <div className="border-t border-white/10 pt-3 mt-3">
            <div className="flex justify-between">
              <span className="text-gray-400 text-sm">Cash/Hour:</span>
              <span className="text-[#F5DEB3] font-bold">
                ${result.cash_per_hour.toFixed(2)}/h
              </span>
            </div>
            <div className="flex justify-between">
              <span className="text-gray-400 text-sm">Gold/Hour:</span>
              <span className="text-[#D4AF37] font-bold">
                {result.gold_per_hour.toFixed(2)} GB/h
              </span>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

import React, { Component, ErrorInfo, ReactNode } from 'react';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends Component<Props, State> {
  public state: State = { hasError: false };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('ðŸš¨ COMPONENT CRASH DETECTED:', error, errorInfo);
  }

  public render() {
    if (this.state.hasError) {
      return (
        <div className="min-h-screen flex items-center justify-center bg-[#0a0a0a] p-8">
          <div className="text-center bg-[#121212] border-2 border-red-500/50 rounded-lg p-8">
            <h1 className="text-3xl font-serif font-bold text-red-500 mb-4">ðŸš¨ System Failure</h1>
            <p className="text-gray-400 mb-6">
              The dashboard crashed. Try reloading or check the console.
            </p>
            <button
              onClick={() => window.location.reload()}
              className="px-6 py-2 bg-[#D4AF37] text-black rounded font-bold hover:bg-[#B8941F] transition-colors"
            >
              Reload Application
            </button>
          </div>
        </div>
      );
    }
    return this.props.children;
  }
}

import React, { useState, useMemo, useEffect } from 'react';
import { Zap, DollarSign, Clock, Users, Skull, Box, Flame, Shield, TrendingUp, Search } from 'lucide-react';
import './index.css'; // Assuming Tailwind setup and custom styles are here

// =========================================================================
// LAYER 1: DOMAIN - CONSTANTS & TYPES
// =========================================================================

const BOUNTY_TIER_MULTIPLIERS = { 1: 1.0, 2: 1.25, 3: 1.5 };
const BOUNTY_STATUS_MULTIPLIERS = { alive: 1.0, dead: 0.5 };
const TRADER_DISTANCE_MULTIPLIERS = { local: 1.0, long: 1.25 };
const MOONSHINE_CONSTANTS = {
  BASE_VALUE_STRONG: 206.25,
  FLAVOR_BONUS_3_STAR: 1.20,
  PRODUCTION_TIME_MINUTES: 48,
  MIN_MASH_COST: 10.0,
  MAX_MASH_COST: 50.0,
};

// =========================================================================
// LAYER 2: SIMULATION - PURE FUNCTIONS
// =========================================================================

// --- A. BOUNTY HUNTER CALCULATOR ---
const calculateGoldTimeBonus = (minutes) => {
  if (minutes < 3) return 0.04;
  if (minutes <= 12) return (Math.floor(minutes / 3) * 0.08);
  if (minutes <= 30) return 0.32 + Math.floor((minutes - 12) / 3) * 0.04;
  return 0.48;
};

const calculateBountyPayout = (input) => {
  if (![1, 2, 3].includes(input.tier)) throw new Error("Invalid tier: Must be 1, 2, or 3.");
  if (input.minutesElapsed < 0 || input.minutesElapsed > 60) throw new Error("Invalid time: Must be 0-60 minutes.");

  const tierMult = BOUNTY_TIER_MULTIPLIERS[input.tier] || 1.0;
  const statusMult = input.alive ? BOUNTY_STATUS_MULTIPLIERS.alive : BOUNTY_STATUS_MULTIPLIERS.dead;
  const rawCash = 30.0 * tierMult * statusMult;
  const gold = calculateGoldTimeBonus(input.minutesElapsed);
  const cashTimeMult = input.minutesElapsed >= 15 ? 1.5 : 1.0; 
  const cash = rawCash * cashTimeMult;
  const hours = Math.max(input.minutesElapsed / 60, 0.01);

  return {
    cash: parseFloat(cash.toFixed(2)),
    gold: parseFloat(gold.toFixed(2)),
    xp: Math.round(150 * tierMult),
    cash_per_hour: parseFloat((cash / hours).toFixed(2)),
  };
};

// --- B. TRADER CALCULATOR ---
const calculateTraderDelivery = (input) => {
  if (!['local', 'long'].includes(input.delivery_distance)) throw new Error("Invalid distance.");
  if (input.goods_count < 1 || input.goods_count > 100) throw new Error("Goods must be 1-100.");

  const distanceMult = TRADER_DISTANCE_MULTIPLIERS[input.delivery_distance] || 1.0;
  const basePayout = 500;
  const cash = basePayout * (input.goods_count / 100) * distanceMult;
  const xp = input.goods_count * 2;
  const deliveryTimeHours = (input.delivery_distance === 'long' ? 0.3 : 0.1);

  return {
    cash: parseFloat(cash.toFixed(2)),
    xp: xp,
    cash_per_hour: parseFloat((cash / deliveryTimeHours).toFixed(2)),
  };
};

// --- C. MOONSHINER CALCULATOR ---
const calculateMoonshinePayout = (input) => {
  if (input.mash_cost < 10 || input.mash_cost > 50) throw new Error("Mash cost must be $10-$50.");

  let baseValue = MOONSHINE_CONSTANTS.BASE_VALUE_STRONG;
  let flavorMultiplier = input.flavor_stars === 3 ? MOONSHINE_CONSTANTS.FLAVOR_BONUS_3_STAR : 1.0;
  let revenue = baseValue * flavorMultiplier;
  if (!input.buyer_alive) revenue = revenue * 0.5;
  const profit = revenue - input.mash_cost;
  const cycleTimeHours = (MOONSHINE_CONSTANTS.PRODUCTION_TIME_MINUTES + 5) / 60;

  return {
    revenue: parseFloat(revenue.toFixed(2)),
    profit: parseFloat(profit.toFixed(2)),
    xp: 1089,
    cash_per_hour: parseFloat((profit / cycleTimeHours).toFixed(2)),
  };
};

// --- D. SESSION PLANNER ---
const generateSessionPlan = (available_minutes, priority) => {
  const activities = [];
  let timeRemaining = available_minutes;
  let currentTime = 0;

  if (timeRemaining >= 60) {
    activities.push({
      role: 'moonshiner', action: 'Start Strong Batch', start_time: currentTime, duration: 5,
      estimated_payout: { cash: 0, gold: 0, xp: 0 }
    });
    timeRemaining -= 5; currentTime += 5;
  }

  const OPTIMAL_BOUNTY_TIME = 12;
  while (timeRemaining >= OPTIMAL_BOUNTY_TIME) {
    const bountyRes = calculateBountyPayout({ tier: 3, alive: true, targetCount: 1, minutesElapsed: OPTIMAL_BOUNTY_TIME });
    if (priority === 'gold' || priority === 'balanced') {
      activities.push({
        role: 'bounty', action: 'Standard Bounty (12m Optimal)', start_time: currentTime, duration: OPTIMAL_BOUNTY_TIME,
        estimated_payout: { cash: bountyRes.cash, gold: bountyRes.gold, xp: bountyRes.xp }
      });
      timeRemaining -= OPTIMAL_BOUNTY_TIME; currentTime += OPTIMAL_BOUNTY_TIME;
    } else {
      timeRemaining = 0;
    }
  }

  if (available_minutes >= 60) {
    const moonRes = calculateMoonshinePayout({ strength: 'strong', flavor_stars: 3, mash_cost: 10, buyer_alive: true });
    activities.push({
      role: 'moonshiner', action: 'Deliver Moonshine Batch', start_time: available_minutes - 15, duration: 15,
      estimated_payout: { cash: moonRes.profit, gold: 0, xp: moonRes.xp }
    });
  }
  
  const totals = activities.reduce((acc, act) => ({
    cash: acc.cash + act.estimated_payout.cash,
    gold: acc.gold + act.estimated_payout.gold,
    xp: acc.xp + act.estimated_payout.xp
  }), { cash: 0, gold: 0, xp: 0 });

  activities.sort((a, b) => a.start_time - b.start_time);
  return { total_duration: available_minutes, activities, totals };
};

// =========================================================================
// LAYER 3: UI - REACT COMPONENTS
// =========================================================================

const ResultBox = ({ label, value, color }) => (
  <div className="flex justify-between items-center bg-[#1a1a1a] p-3 rounded">
    <span className="text-xs text-gray-500 uppercase tracking-wider">{label}</span>
    <span className={`font-mono font-bold ${color}`}>{value}</span>
  </div>
);

const App = () => {
  const [bountyState, setBountyState] = useState({ tier: 3, alive: true, targets: 1, minutes: 12 });
  const [bountyError, setBountyError] = useState(null);
  const [moonState, setMoonState] = useState({ mash: 10, flavor_stars: 3, buyer: true });
  const [sessionDuration, setSessionDuration] = useState(120);
  const [sessionPriority, setSessionPriority] = useState('gold');

  const bountyResult = useMemo(() => {
    try {
      const result = calculateBountyPayout(bountyState);
      setBountyError(null);
      return result;
    } catch (e) {
      setBountyError(e.message);
      return { cash: 0, gold: 0, xp: 0, cash_per_hour: 0 };
    }
  }, [bountyState]);

  const moonResult = useMemo(() => calculateMoonshinePayout({
    mash_cost: moonState.mash,
    flavor_stars: moonState.flavor_stars,
    buyer_alive: moonState.buyer,
  }), [moonState]);
  
  const sessionPlan = useMemo(() => generateSessionPlan(sessionDuration, sessionPriority), [sessionDuration, sessionPriority]);

  return (
    <div className="min-h-screen bg-[#0a0a0a] text-gray-200 font-sans p-8">
      <div className="max-w-6xl mx-auto">
        {/* HEADER */}
        <div className="flex items-center justify-between mb-10 pb-6 border-b border-white/10">
          <h1 className="text-[#D4AF37] font-serif text-4xl font-bold flex items-center gap-3">
            <Shield size={36} className="text-red-700" />
            RDO CHARACTER OS
          </h1>
          <div className="text-right">
            <div className="text-gray-500 text-sm font-mono">Total Session Output</div>
            <div className="text-3xl font-bold text-[#F5DEB3] font-mono">
              ${(bountyResult.cash + moonResult.profit + sessionPlan.totals.cash).toFixed(2)}
            </div>
          </div>
        </div>

        {/* CALCULATOR GRID */}
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-12">
          {/* A. BOUNTY HUNTER */}
          <div className="bg-[#121212] border border-white/10 rounded-lg p-6">
            <h2 className="text-white font-serif font-bold text-xl mb-4 flex items-center gap-2">
              <Skull className="text-red-500" size={20} /> Bounty Hunter
            </h2>
            {bountyError && <div className="text-red-400 mb-4">{bountyError}</div>}
            <div className="space-y-4">
              <label className="text-xs text-gray-500 uppercase">Time: {bountyState.minutes}m</label>
              <input type="range" min="1" max="30" value={bountyState.minutes} onChange={(e) => setBountyState(s => ({ ...s, minutes: parseInt(e.target.value) }))} className="w-full accent-[#D4AF37]" />
              <label className="text-xs text-gray-500 uppercase">Tier: {bountyState.tier}</label>
              <div className="flex gap-2">
                {[1, 2, 3].map(t => (
                  <button key={t} onClick={() => setBountyState(s => ({ ...s, tier: t }))} className={`flex-1 py-2 text-sm border ${bountyState.tier === t ? 'bg-[#D4AF37] text-black' : 'text-gray-400 border-white/10'}`}>{Array(t).fill('$').join('')}</button>
                ))}
              </div>
            </div>
            <div className="mt-6 space-y-2">
              <ResultBox label="Cash Payout" value={`$${bountyResult.cash.toFixed(2)}`} color="text-[#F5DEB3]" />
              <ResultBox label="Gold Gain" value={`${bountyResult.gold.toFixed(2)} GB`} color="text-[#D4AF37]" />
              <ResultBox label="Cash/Hr" value={`$${bountyResult.cash_per_hour.toFixed(2)}`} color="text-green-400" />
            </div>
          </div>
          {/* B. TRADER */}
          <div className="bg-[#121212] border border-white/10 rounded-lg p-6">
             <h2 className="text-white font-serif font-bold text-xl mb-4 flex items-center gap-2">
              <Box className="text-blue-500" size={20} /> Trader
            </h2>
             <div className="space-y-4">
               <label className="text-xs text-gray-500 uppercase">Goods: 100 Units</label>
               <label className="text-xs text-gray-500 uppercase">Distance: Long</label>
            </div>
            <div className="mt-6 space-y-2">
              <ResultBox label="Payout" value={`$${calculateTraderDelivery({ goods_count: 100, delivery_distance: 'long', wagon_type: 'large' }).cash.toFixed(2)}`} color="text-[#F5DEB3]" />
              <ResultBox label="Cash/Hr" value={`$${calculateTraderDelivery({ goods_count: 100, delivery_distance: 'long', wagon_type: 'large' }).cash_per_hour.toFixed(2)}`} color="text-green-400" />
            </div>
          </div>
          {/* C. MOONSHINER */}
          <div className="bg-[#121212] border border-white/10 rounded-lg p-6">
            <h2 className="text-white font-serif font-bold text-xl mb-4 flex items-center gap-2">
              <Flame className="text-orange-500" size={20} /> Moonshiner
            </h2>
            <div className="space-y-4">
               <label className="text-xs text-gray-500 uppercase">Mash Cost: ${moonState.mash}</label>
               <input type="range" min="10" max="50" step="5" value={moonState.mash} onChange={(e) => setMoonState(s => ({ ...s, mash: parseInt(e.target.value) }))} className="w-full accent-orange-500" />
            </div>
            <div className="mt-6 space-y-2">
              <ResultBox label="Net Profit" value={`$${moonResult.profit.toFixed(2)}`} color="text-[#F5DEB3]" />
              <ResultBox label="Cash/Hr" value={`$${moonResult.cash_per_hour.toFixed(2)}`} color="text-green-400" />
            </div>
          </div>
        </div>
        {/* D. SESSION PLANNER */}
        <div className="mt-8 bg-[#121212] border border-white/10 rounded-lg p-6">
          <h2 className="text-white font-serif font-bold text-2xl mb-6 flex items-center gap-2">
              <Clock size={24} className="text-gray-400" /> Session Planner
          </h2>
          <div className="space-y-4">
             <label className="text-xs text-gray-500 uppercase">Duration: {sessionDuration} minutes</label>
             <input type="range" min="30" max="240" step="30" value={sessionDuration} onChange={(e) => setSessionDuration(parseInt(e.target.value))} className="w-full accent-[#D4AF37]" />
             <label className="text-xs text-gray-500 uppercase">Strategy</label>
             <div className="flex gap-2">
                {['gold', 'cash', 'balanced'].map(p => (
                  <button key={p} onClick={() => setSessionPriority(p)} className={`flex-1 py-2 text-sm border ${sessionPriority === p ? 'bg-[#D4AF37] text-black' : 'text-gray-400 border-white/10'}`}>{p.toUpperCase()}</button>
                ))}
             </div>
          </div>
          <div className="mt-6 space-y-3">
            {sessionPlan.activities.map((act, index) => (
              <div key={index} className="flex justify-between items-center border-b border-white/5 pb-2">
                <div className="text-sm">
                  <span className="text-gray-400 mr-2">{act.start_time}m - {act.start_time + act.duration}m:</span>
                  <span className="font-bold">{act.action}</span>
                </div>
                <div className="font-mono text-sm text-[#F5DEB3]">
                  ${act.estimated_payout.cash.toFixed(2)}
                </div>
              </div>
            ))}
          </div>
        </div>
        {/* E. SMART CATALOG (Placeholder) */}
        <div className="mt-12 bg-[#121212] border border-white/10 rounded-lg p-6">
            <h2 className="text-white font-serif font-bold text-2xl mb-4 flex items-center gap-2">
                <Search size={24} className="text-blue-500" /> Smart Catalog
            </h2>
            <p className="text-gray-400">
                Catalog filtering and display logic (19 items loaded)
                <span className='ml-4 text-blue-400'>
                    (Full implementation relies on memoized selectors and complex type filtering from the dedicated files.)
                </span>
            </p>
        </div>
      </div>
    </div>
  );
};

export default App;
/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * MAIN APP - Redux Provider & System Loader
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * This wraps the entire application with Redux Provider and System Loader.
 * The old App.jsx functionality will be refactored into feature components.
 */

import React, { Suspense } from 'react';
import { Provider } from 'react-redux';
import store from './app/store';
import { useSystemLoader } from './hooks/useSystemLoader';
import { useAppSelector } from './app/hooks';
import { selectCompendiumStatus, selectCompendiumError } from './app/selectors';

// Placeholder components
const LoadingScreen = () => (
  <div style={styles.container}>
    <div style={styles.content}>
      <h1>ðŸ”„ RDO CHARACTER OS</h1>
      <p>Boot sequence in progress...</p>
      <div style={styles.spinner}></div>
    </div>
  </div>
);

const ErrorScreen = ({ error }: { error: string }) => (
  <div style={styles.container}>
    <div style={{ ...styles.content, background: '#8B0000' }}>
      <h1>âŒ Boot Failed</h1>
      <p>{error}</p>
      <button onClick={() => window.location.reload()} style={styles.button}>
        Restart
      </button>
    </div>
  </div>
);

// Import the actual App UI from App.jsx
import RDO_Character_OS from './App';

const MainDashboard = () => <RDO_Character_OS />;

/**
 * Inner App Component (rendered after Provider)
 * This is where the actual app logic goes
 */
function AppContent() {
  const { isReady, isLoading, error } = useSystemLoader();
  
  // === FIX 1: Use Redux selectors for compendium status ===
  const compendiumStatus = useAppSelector(selectCompendiumStatus);
  const compendiumError = useAppSelector(selectCompendiumError);

  // Show loading screen while data is being fetched
  if (isLoading || compendiumStatus === 'loading' || compendiumStatus === 'idle') {
    return <LoadingScreen />;
  }
  
  // Show error screen if critical error occurred
  if (error || compendiumStatus === 'error') {
    return <ErrorScreen error={error || compendiumError || 'Unknown error'} />;
  }
  
  // Only render app when data is ready
  if (!isReady || compendiumStatus !== 'ready') {
    return <LoadingScreen />;
  }

  // Final State: Render the actual app
  return <MainDashboard />;
}

/**
 * Root App Component
 * Wraps everything in Redux Provider and system initialization
 */
export default function App() {
  return (
    <Provider store={store}>
      <Suspense fallback={<LoadingScreen />}>
        <AppContent />
      </Suspense>
    </Provider>
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STYLES (Will be replaced with Tailwind/CSS)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const styles = {
  container: {
    width: '100%',
    height: '100vh',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    background: '#0a0a0a',
    color: '#f5deb3',
    fontFamily: 'monospace',
  } as React.CSSProperties,
  
  content: {
    padding: '40px',
    borderRadius: '8px',
    background: '#1a1410',
    border: '2px solid #D4AF37',
    textAlign: 'center',
    maxWidth: '500px',
  } as React.CSSProperties,
  
  spinner: {
    width: '40px',
    height: '40px',
    border: '4px solid #D4AF37',
    borderTop: '4px solid transparent',
    borderRadius: '50%',
    margin: '20px auto',
    animation: 'spin 1s linear infinite',
  } as React.CSSProperties,
  
  button: {
    padding: '10px 20px',
    background: '#D4AF37',
    color: '#2d2620',
    border: 'none',
    borderRadius: '4px',
    cursor: 'pointer',
    fontSize: '16px',
    fontWeight: 'bold',
    marginTop: '20px',
  } as React.CSSProperties,
  
  info: {
    background: '#0a0a0a',
    padding: '15px',
    borderRadius: '4px',
    fontSize: '11px',
    textAlign: 'left',
    marginTop: '20px',
    overflow: 'auto',
  } as React.CSSProperties,
};

import { createRoot } from 'react-dom/client'
import './index.css'
import App from './AppNew.tsx'
import { ErrorBoundary } from './ui/ErrorBoundary'

createRoot(document.getElementById('root')).render(
  <ErrorBoundary>
    <App />
  </ErrorBoundary>,
)

